<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Interpolation kernels for Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Interpolation kernels for Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../basics/">Basic usage</a></li><li><a class="tocitem" href="../kernels/">Kernels</a></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Kernel-supports-1"><span>Kernel supports</span></a></li><li><a class="tocitem" href="#Interpolation-kernels-1"><span>Interpolation kernels</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/InterpolationKernels.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference-1"><a class="docs-heading-anchor" href="#Reference-1">Reference</a><a class="docs-heading-anchor-permalink" href="#Reference-1" title="Permalink"></a></h1><p>The following provides detailled documentation about types and methods provided by the <code>InterpolationKernels</code> package.  This information is also available from the REPL by typing <code>?</code> followed by the name of a method or a type.</p><h2 id="Kernel-supports-1"><a class="docs-heading-anchor" href="#Kernel-supports-1">Kernel supports</a><a class="docs-heading-anchor-permalink" href="#Kernel-supports-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.Support" href="#InterpolationKernels.Support"><code>InterpolationKernels.Support</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>InterpolationKernels.Support{T,S,L,R}</code> is the abstract type for the support of an interpolation kernel parameterized by the floating-point type <code>T</code> used for computations, the integer size <code>S</code> of the support and the types <code>L</code> and <code>R</code> of the left and right bound which can be <code>InterpolationKernels.Open</code> or <code>InterpolationKernels.Closed</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.SymmetricSupport" href="#InterpolationKernels.SymmetricSupport"><code>InterpolationKernels.SymmetricSupport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterpolationKernels.SymmetricSupport{T,S,L,R}() -&gt; sup</code></pre><p>yields an instance of a symmetric support parameterized by the floating-point type <code>T</code>, the integer size <code>S</code> of the support and the types <code>L</code> and <code>R</code> of the left and right bound which can be <code>InterpolationKernels.Open</code> or <code>InterpolationKernels.Closed</code>.</p><p>Depending on <code>L</code> and <code>R</code>, the support is:</p><pre><code class="language-none">(L,R) = (Open,Open) -------&gt; sup = (-S/2,S/2)
(L,R) = (Closed,Open) -----&gt; sup = [-S/2,S/2)
(L,R) = (Open,Closed) -----&gt; sup = (-S/2,S/2]
(L,R) = (Closed,Closed) ---&gt; sup = [-S/2,S/2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L64-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.LeftAnchoredSupport" href="#InterpolationKernels.LeftAnchoredSupport"><code>InterpolationKernels.LeftAnchoredSupport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterpolationKernels.LeftAnchoredSupport{T,S,L,R}(a)</code></pre><p>yields an instance of a support with lower bound <code>a</code> and parameterized by the floating-point type <code>T</code>, the integer size <code>S</code> of the support and the types <code>L</code> and <code>R</code> of the left and right bound which can be <code>InterpolationKernels.Open</code> or <code>InterpolationKernels.Closed</code>.</p><p>Depending on <code>L</code> and <code>R</code>, the support is:</p><pre><code class="language-none">(L,R) = (Open,Open) -------&gt; sup = (a,a+S)
(L,R) = (Closed,Open) -----&gt; sup = [a,a+S)
(L,R) = (Open,Closed) -----&gt; sup = (a,a+S]
(L,R) = (Closed,Closed) ---&gt; sup = [a,a+S]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L82-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.RightAnchoredSupport" href="#InterpolationKernels.RightAnchoredSupport"><code>InterpolationKernels.RightAnchoredSupport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterpolationKernels.RightAnchoredSupport{T,S,L,R}(b)</code></pre><p>yields an instance of a support with upper bound <code>b</code> and parameterized by the floating-point type <code>T</code>, the integer size <code>S</code> of the support and the types <code>L</code> and <code>R</code> of the left and right bound which can be <code>InterpolationKernels.Open</code> or <code>InterpolationKernels.Closed</code>.</p><p>Depending on <code>L</code> and <code>R</code>, the support is:</p><pre><code class="language-none">(L,R) = (Open,Open) -------&gt; sup = (b-S,b)
(L,R) = (Closed,Open) -----&gt; sup = [b-S,b)
(L,R) = (Open,Closed) -----&gt; sup = (b-S,b]
(L,R) = (Closed,Closed) ---&gt; sup = [b-S,b]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L102-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.infimum" href="#InterpolationKernels.infimum"><code>InterpolationKernels.infimum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">InterpolationKernels.infimum(sup) -&gt; a</code></pre><p>yields the greatest lower bound <code>a</code> of the kernel support <code>sup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.supremum" href="#InterpolationKernels.supremum"><code>InterpolationKernels.supremum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">InterpolationKernels.supremum(sup) -&gt; b</code></pre><p>yields the least upper bound <code>b</code> of the kernel support <code>sup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L122-L127">source</a></section></article><h2 id="Interpolation-kernels-1"><a class="docs-heading-anchor" href="#Interpolation-kernels-1">Interpolation kernels</a><a class="docs-heading-anchor-permalink" href="#Interpolation-kernels-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.Kernel" href="#InterpolationKernels.Kernel"><code>InterpolationKernels.Kernel</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Interpolation Kernels</strong></p><p>An interpolation kernel <code>Kernel{T,S}</code> is parametrized by the floating-point type <code>T</code> of its coefficients and by the integer size <code>S</code> of its support.  For efficiency reasons, only kernels with (small) finite size supports are implemented.</p><p>A kernel <code>ker</code> is a callable object which may be used as a function with a real argument:</p><pre><code class="language-none">ker(x::Real)</code></pre><p>yields kernel value at offset <code>x</code>.  Whatever the type of <code>x</code>, <code>ker(x)</code> is always of type <code>T = eltype(ker)</code> the floating-point type associated with <code>ker</code>. All kernel supports are symmetric; that is <code>ker(x)</code> is zero if <code>abs(x) &gt; S/2</code> with <code>S = length(ker)</code> the size of the kernel support.</p><p><strong>Kernel floating-point type conversion</strong></p><p>Called as a function with a real argument, a given kernel returns a value of its associated floating-point type.  This has been chosen to have fast interpolation methods.  Converting a kernel <code>ker</code> to use floating-point type <code>T</code> is simply done by one of:</p><pre><code class="language-none">T(ker)
Kernel{T}(ker)
convert(Kernel{T}, ker)</code></pre><p>Beware that changing the floating-point type may lead to a loss of precision if the kernel has numerical parameters.</p><p><strong>Common methods</strong></p><p>A few common methods are specialized for any interpolation kernel <code>ker</code>:</p><pre><code class="language-none">eltype(ker) -&gt; T</code></pre><p>yields the floating-point type for calculations,</p><pre><code class="language-none">length(ker) -&gt; S</code></pre><p>yield the size the support of <code>ker</code> which is also the number of neighbors involved in an interpolation by this kernel,</p><pre><code class="language-none">values(ker)</code></pre><p>yields a tuple of the parameters of <code>ker</code> such that an identical instance can be built by:</p><pre><code class="language-none">typeof(ker)(values(ker)...)</code></pre><p>finally:</p><pre><code class="language-none">compute_offset_and_weights(ker, x) -&gt; off, (w1, w2, ..., wS)</code></pre><p>yields the offset <code>off</code> and an <code>S</code>-tuple of interpolation weights to interpolate an array at coordinate <code>x</code> (in fractional index units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L145-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.iscardinal" href="#InterpolationKernels.iscardinal"><code>InterpolationKernels.iscardinal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iscardinal(ker)</code></pre><p>yields whether the kernel <code>ker</code> is zero for non-zero integer arguments. Cardinal kernels are directly suitable for interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.isnormalized" href="#InterpolationKernels.isnormalized"><code>InterpolationKernels.isnormalized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnormalized(ker)</code></pre><p>yields whether the kernel <code>ker</code> has the partition of unity property.  That is, the sum of the values computed by the kernel <code>ker</code> on a unit spaced grid is equal to one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L215-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.support" href="#InterpolationKernels.support"><code>InterpolationKernels.support</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">InterpolationKernels.support(ker) -&gt; sup</code></pre><p>yields the support of the interpolation kernel <code>ker</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L390-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.brief" href="#InterpolationKernels.brief"><code>InterpolationKernels.brief</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">InterpolationKernels.brief(ker)</code></pre><p>yields a brief description of the kernel type or instance <code>ker</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L1324-L1329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.compute_weights" href="#InterpolationKernels.compute_weights"><code>InterpolationKernels.compute_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">InterpolationKernels.compute_weights(ker, t) -&gt; wgt</code></pre><p>computes the interpolation weights returned by <a href="#InterpolationKernels.compute_offset_and_weights"><code>InterpolationKernels.compute_offset_and_weights</code></a> for kernel <code>ker</code> with symmetric support.  Assuming interpolation is performed at at position <code>x</code>, argument <code>t</code> is given by:</p><pre><code class="language-none"> t = x - floor(x)     if length(ker) is even, hence t ∈ [0,1)
 t = x - round(x)     if length(ker) is odd,  hence t ∈ [-1/2,+1/2]</code></pre><p>The returned weights are then:</p><pre><code class="language-none"> wgt = ntuple(i -&gt; ker(t + k - i), length(ker))</code></pre><p>where <code>k = (length(ker) + 1) &gt;&gt; 1</code> (i.e., integer division of <code>length(ker)+1</code> by 2).  These conventions have been adopted so that, by specializing the <code>compute_weights</code> method, computing the <code>length(ker)</code> weights at the same time may be done in much fewer operations than calling <code>ker</code> as a function for each weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L341-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.compute_offset_and_weights" href="#InterpolationKernels.compute_offset_and_weights"><code>InterpolationKernels.compute_offset_and_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">InterpolationKernels.compute_offset_and_weights(ker, x) -&gt; off, wgt</code></pre><p>yields the index offset <code>off</code> and the weights <code>wgt</code> to interpolate with kernel <code>ker</code> at position <code>x</code> in fractional index units.  The offset is a scalar and the weights are an <code>n</code>-tuple with <code>n = length(ker)</code> the size of the support of the kernel, all returned values have the same floating point type <code>eltype(ker)</code> as the kernel.</p><p>Not taking into account boundary conditions, interpolating a vector <code>A</code> at position <code>x</code> would then write:</p><pre><code class="language-none">off, wgt = InterpolationKernels.compute_offset_and_weights(ker, x)
k = Int(off) # here boundary conditions should be imposed
result = wgt[1]*A[k+1] + ... + wgt[n]*A[k+n]</code></pre><p>Note that 1-based indexing is assumed by <code>compute_offset_and_weights</code> to interpret the position <code>x</code> and compute the offset <code>off</code>.  If this is not the case, the code should be:</p><pre><code class="language-none">j1 = first(axes(A,1)) # first index in A
off, wgt = InterpolationKernels.compute_offset_and_weights(ker, x - (j1 - 1))
k = Int(off) + (j1 - 1) # here boundary conditions should be imposed
result = wgt[1]*A[k+1] + ... + wgt[n]*A[k+n]</code></pre><p>where expression <code>x - (j1 - 1)</code> is assuming that the position <code>x</code> is in fractional index for <code>A</code>, that is <code>x = j1</code> at the first entry of <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For fast computations, this method should be specialized for specific kernel types.  For kernels with symmetric support, the method <a href="#InterpolationKernels.compute_weights"><code>InterpolationKernels.compute_weights</code></a> is called by <code>compute_offset_and_weights</code> to calculate the interpolation weights; for such kernels it is sufficient to specialize <code>compute_weights</code> instead of <code>compute_offset_and_weights</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L232-L268">source</a></section></article><h3 id="B-splines-1"><a class="docs-heading-anchor" href="#B-splines-1">B-splines</a><a class="docs-heading-anchor-permalink" href="#B-splines-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.BSpline" href="#InterpolationKernels.BSpline"><code>InterpolationKernels.BSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSpline{S,T}()</code></pre><p>yields a B-spline (short for <em>basis spline</em>) of order <code>S</code> that is a piecewise polynomial function of degree <code>S - 1</code> on a support of length <code>S</code>.  The parameter <code>T</code> is the floating-point type for computations, <code>T = Float64</code> is assuled if this parameter is not specified.</p><p>Fr now, not all B-spline are implemented in <code>InterpolationKernels</code>, <code>S</code> must be: <code>1</code> (for a <strong>rectangular</strong> B-spline), <code>2</code> (for a <strong>linear</strong> B-spline), <code>3</code> (for a <strong>quadratic</strong> B-spline), or <code>4</code> (for a <strong>cubic</strong> B-spline).</p><p>If <code>ker</code> is a B-spline, then <code>ker&#39;</code> is its derivative which can also be directly constructed by calling <a href="#InterpolationKernels.BSplinePrime"><code>BSplinePrime</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The derivative of B-spline of order <code>S ≤ 2</code> is not defined everywhere.  It is allowed to take their derivative but it (arbitrarily) yields zero where not defined.  Returning <code>NaN</code> would have been more correct but it has been considered that it would do more harm than good in practice.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L400-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.BSplinePrime" href="#InterpolationKernels.BSplinePrime"><code>InterpolationKernels.BSplinePrime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSplinePrime{S,T}()</code></pre><p>yields the derivative of a B-spline of order <code>S</code> for floating-point <code>T</code>.</p><p>See the caveats in <a href="#InterpolationKernels.BSpline"><code>BSpline</code></a> about taking the derivative of B-splines of order <code>S ≤ 2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L425-L433">source</a></section></article><h3 id="Generic-cubic-spline-1"><a class="docs-heading-anchor" href="#Generic-cubic-spline-1">Generic cubic spline</a><a class="docs-heading-anchor-permalink" href="#Generic-cubic-spline-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.CubicSpline" href="#InterpolationKernels.CubicSpline"><code>InterpolationKernels.CubicSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CubicSpline{T}(a, b) -&gt; ker</code></pre><p>yields an instance of a generic cubic spline for floating-point type <code>T</code> and parameters <code>a = ker&#39;(1)</code> and <code>b = ker(1)</code> the slope and the value of the function <code>ker(x)</code> at <code>x = 1</code>.</p><p>A cubic spline kernel is at least C¹ continuous, the expression <code>ker&#39;</code> yields a kernel instance implementing the 1st derivative of the generic cubic spline <code>ker</code> (see <a href="#InterpolationKernels.CubicSplinePrime"><code>CubicSplinePrime</code></a> to directly build a derivative).</p><p>Depending on the values of the parameters <code>a</code> and <code>b</code>, more specific cubic spline kernels can be emulated:</p><ul><li><p><code>CubicSpline{T}(-1/2,1/6)</code> yields a cubic B-spline as built by <code>BSpline{4,T}()</code>.</p></li><li><p><code>CubicSpline{T}(a,0)</code> yields a cardinal cubic spline as built by <code>CardinalCubicSpline{T}(a)</code>.</p></li><li><p><code>CubicSpline{T}(-1/2,0)</code> yields a Catmull-Rom kernel as built by <code>CatmullRomSpline{T}()</code>.</p></li><li><p><code>CubicSpline{T}(-b/2-c,b/6)</code> yields Mitchell &amp; Netravali cubic spline as built by <code>MitchellNetravaliSpline{T}(b,c)</code>.</p></li></ul><p>Instances of <code>CubicSpline</code> are very well optimized and, in practice, they may be as fast or even faster than these more specialized counterparts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L642-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.CubicSplinePrime" href="#InterpolationKernels.CubicSplinePrime"><code>InterpolationKernels.CubicSplinePrime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CubicSplinePrime{T}(a, b)</code></pre><p>yields a kernel instance that is the 1st derivative of the generic cubic spline of parameters <code>a</code> and <code>b</code> (see <a href="#InterpolationKernels.CubicSpline"><code>CubicSpline</code></a>) for floating-point type <code>T</code> (<code>Float64</code> by default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L673-L680">source</a></section></article><h3 id="Cardinal-cubic-splines-1"><a class="docs-heading-anchor" href="#Cardinal-cubic-splines-1">Cardinal cubic splines</a><a class="docs-heading-anchor-permalink" href="#Cardinal-cubic-splines-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.CardinalCubicSpline" href="#InterpolationKernels.CardinalCubicSpline"><code>InterpolationKernels.CardinalCubicSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CardinalCubicSpline{T}(a)</code></pre><p>yields an instance of the Keys family of cardinal cubic splines for floating-point type <code>T</code> and parameter <code>a = ker&#39;(1)</code> the slope of the function <code>ker(x)</code> at <code>x = 1</code>.</p><p>These kernels are C¹ continuous piecewise normalized cardinal cubic spline which depend on one parameter <code>a</code> and defined by:</p><pre><code class="language-none">ker(x) = 1 + ((2 + a)*|x| - (3 + a))*x^2    if |x| ≤ 1
         a*(|x| - 1)*(|x| - 2)^2            if 1 ≤ |x| ≤ 2
         0                                  if |x| ≥ 2</code></pre><p>The expression <code>ker&#39;</code> yields a kernel instance which is the 1st derivative of the Keys kernel <code>ker</code> (also see the constructor <a href="#InterpolationKernels.CardinalCubicSplinePrime"><code>CardinalCubicSplinePrime</code></a>).</p><p>Reference:</p><ul><li>Keys, Robert, G., &quot;Cubic Convolution Interpolation for Digital Image Processing&quot;, IEEE Trans. Acoustics, Speech, and Signal Processing, Vol. ASSP-29, No. 6, December 1981, pp. 1153-1160.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L828-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.CardinalCubicSplinePrime" href="#InterpolationKernels.CardinalCubicSplinePrime"><code>InterpolationKernels.CardinalCubicSplinePrime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CardinalCubicSplinePrime{T}(a)</code></pre><p>yields a kernel instance that is the 1st derivative of the Keys cardinal cubic spline (see <a href="#InterpolationKernels.CardinalCubicSpline"><code>CardinalCubicSpline</code></a>) for floating-point type <code>T</code> and parameter <code>a</code>.  This derivative is given by:</p><pre><code class="language-none">ker′(x) = (3(a + 2)*|x| - 2(a + 3))*x           if |x| ≤ 1
          (3a)*(|x| - 2)*(|x| - 4/3)*sign(x)    if 1 ≤ |x| ≤ 2
          0                                     if |x| ≥ 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L906-L917">source</a></section></article><h3 id="Catmull-Rom-interpolation-kernel-1"><a class="docs-heading-anchor" href="#Catmull-Rom-interpolation-kernel-1">Catmull-Rom interpolation kernel</a><a class="docs-heading-anchor-permalink" href="#Catmull-Rom-interpolation-kernel-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.CatmullRomSpline" href="#InterpolationKernels.CatmullRomSpline"><code>InterpolationKernels.CatmullRomSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CatmullRomSpline{T}()</code></pre><p>yields an instance of the Catmull-Rom interpolation kernel for floating-point type <code>T</code> which is assumed to be <code>Float64</code> if omitted.</p><p>Catmull-Rom interpolation kernel is a cardinal piecewise cubic spline defined by:</p><pre><code class="language-none">ker(x) = ((3/2)*|x| - (5/2))*x^2 + 1             if |x| ≤ 1
         (((5/2) - (1/2)*|x|)*|x| - 4)*|x| + 2   if 1 ≤ |x| ≤ 2
         0                                       if |x| ≥ 2</code></pre><p>The expression <code>ker&#39;</code> yields a kernel instance which is the 1st derivative of the Catmull-Rom interpolation kernel <code>ker</code> (also see the constructor <a href="#InterpolationKernels.CatmullRomSplinePrime"><code>CatmullRomSplinePrime</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L957-L974">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.CatmullRomSplinePrime" href="#InterpolationKernels.CatmullRomSplinePrime"><code>InterpolationKernels.CatmullRomSplinePrime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CatmullRomSplinePrime{T}()</code></pre><p>yields a kernel instance that is the 1st derivative of the Catmull-Rom interpolation kernel (see <a href="#InterpolationKernels.CatmullRomSpline"><code>CatmullRomSpline</code></a>) for floating-point type <code>T</code> which is assumed to be <code>Float64</code> if omitted.</p><p>The 1st derivative of the Catmull-Rom interpolation kernel is given by:</p><pre><code class="language-none">ker′(x) = ((9/2)*|x| - 5)*x                      if a = |x| ≤ 1
          (5 - (3/2)*|x|)*x - 4*sign(x)          if 1 ≤ |x| ≤ 2
          0                                      if |x| ≥ 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L1004-L1017">source</a></section></article><h3 id="Mitchell-Netravali-kernels-1"><a class="docs-heading-anchor" href="#Mitchell-Netravali-kernels-1">Mitchell-Netravali kernels</a><a class="docs-heading-anchor-permalink" href="#Mitchell-Netravali-kernels-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.MitchellNetravaliSpline" href="#InterpolationKernels.MitchellNetravaliSpline"><code>InterpolationKernels.MitchellNetravaliSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MitchellNetravaliSpline{T}(b=1/3, c=1/3)</code></pre><p>yields an instance of the Mitchell &amp; Netravali family of kernels for floating-point type <code>T</code> and parameters <code>(b,c)</code>.</p><p>These kernels are cubic splines which depends on 2 parameters, <code>b</code> and <code>c</code>. Whatever the values of <code>(b,c)</code>, Mitchell &amp; Netravali kernels are normalized, even and C¹ continuous functions (these kernels and their first derivatives are continuous).</p><p>Taking <code>b = 0</code> yields the family of cardinal cubic splines (see <a href="#InterpolationKernels.CardinalCubicSpline"><code>CardinalCubicSpline</code></a>) and is a sufficient and necessary condition to have Mitchell &amp; Netravali kernels be cardinal functions.</p><p>Using the constraint: <code>b + 2c = 1</code> yields a cubic filter with, at least, quadratic order approximation.</p><p>Some specific values of <code>(b,c)</code> yield other well known kernels:</p><pre><code class="language-none">(b,c) = (1,0)      --&gt; cubic B-spline
(b,c) = (0,-a)     --&gt; Keys&#39;s cardinal cubic spline CardinalCubicSpline(a)
(b,c) = (0,1/2)    --&gt; Catmull-Rom kernel CatmullRomSpline()
(b,c) = (b,0)      --&gt; Duff&#39;s tensioned B-spline
(b,c) = (6β,-α-3β) --&gt; generic cubic spline CubicSpline(α,β)
(b,c) = (1/3,1/3)  --&gt; recommended by Mitchell-Netravali</code></pre><p>The expression <code>ker&#39;</code> yields a kernel instance which is the 1st derivative of the Mitchell &amp; Netravali kernel <code>ker</code> (also see the constructor <a href="#InterpolationKernels.MitchellNetravaliSplinePrime"><code>MitchellNetravaliSplinePrime</code></a>).</p><p>Mitchell &amp; Netravali family of kernels are currently instances of <a href="#InterpolationKernels.CubicSpline"><code>CubicSpline</code></a>.</p><p>Reference:</p><ul><li><a href="http://www.cs.utexas.edu/users/fussell/courses/cs384g/lectures/mitchell/Mitchell.pdf">Mitchell &amp; Netravali, &quot;<em>Reconstruction Filters in Computer Graphics</em>&quot;, in Computer Graphics, Vol. 22, Num. 4 (1988)</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L1078-L1118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.MitchellNetravaliSplinePrime" href="#InterpolationKernels.MitchellNetravaliSplinePrime"><code>InterpolationKernels.MitchellNetravaliSplinePrime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MitchellNetravaliSplinePrime([T=Float64,] [b=1/3, c=1/3,] B=Flat)</code></pre><p>yields a kernel instance that is the 1st derivative of the Mitchell &amp; Netravali kernel (see <a href="#InterpolationKernels.MitchellNetravaliSpline"><code>MitchellNetravaliSpline</code></a>) for floating-point type <code>T</code>, parameters <code>b</code> and <code>c</code> and boundary conditions <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L1122-L1129">source</a></section></article><h3 id="Lanczos-re-sampling-kernels-1"><a class="docs-heading-anchor" href="#Lanczos-re-sampling-kernels-1">Lanczos re-sampling kernels</a><a class="docs-heading-anchor-permalink" href="#Lanczos-re-sampling-kernels-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.LanczosKernel" href="#InterpolationKernels.LanczosKernel"><code>InterpolationKernels.LanczosKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LanczosKernel{S,T}()</code></pre><p>yields an instance of a Lanczos re-sampling kernel of support size <code>S</code> (which must be even) and for floating-point type <code>T</code>.</p><p>The Lanczos re-sampling kernels are even cardinal functions which tend to be normalized for large support size.  They are defined by:</p><pre><code class="language-none">ker(x) = S/(2*(π*x)^2)*sin(π*x)*sin(2*π*x/S)     if |x| ≤ S/2
         0                                       if |x| ≥ S/2</code></pre><p>The expression <code>ker&#39;</code> yields the first derivative of a Lanczos re-sampling kernel <code>ker</code> (also see the constructor <a href="#InterpolationKernels.LanczosKernelPrime"><code>LanczosKernelPrime</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L1157-L1172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InterpolationKernels.LanczosKernelPrime" href="#InterpolationKernels.LanczosKernelPrime"><code>InterpolationKernels.LanczosKernelPrime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LanczosKernelPrime{S,T}()</code></pre><p>yields a kernel instance that is the 1st derivative of the Lanczos re-sampling kernel (see <a href="#InterpolationKernels.LanczosKernel"><code>LanczosKernel</code></a>) of support size <code>S</code> and for floating-point type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/InterpolationKernels.jl/blob/55616afa7a089028c66536606c5281d8939b5ec5/src/InterpolationKernels.jl#L1174-L1181">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interpolation/">« Interpolation</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 2 April 2021 20:05">Friday 2 April 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
