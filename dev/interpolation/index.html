<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interpolation ¬∑ Interpolation kernels for Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Interpolation kernels for Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../basics/">Basic usage</a></li><li><a class="tocitem" href="../kernels/">Kernels</a></li><li><a class="tocitem" href="../boundaries/">Boundary conditions</a></li><li class="is-active"><a class="tocitem" href>Interpolation</a><ul class="internal"><li><a class="tocitem" href="#Interpolation-principles-1"><span>Interpolation principles</span></a></li><li><a class="tocitem" href="#Interpolation-weights-1"><span>Interpolation weights</span></a></li><li><a class="tocitem" href="#Example:-fine-shifting-1"><span>Example: fine shifting</span></a></li></ul></li><li><a class="tocitem" href="../library/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interpolation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interpolation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/InterpolationKernels.jl/blob/master/docs/src/interpolation.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interpolation-1"><a class="docs-heading-anchor" href="#Interpolation-1">Interpolation</a><a class="docs-heading-anchor-permalink" href="#Interpolation-1" title="Permalink"></a></h1><p>Interpolation kernels, as their name suggest, are designed for interpolating arrays.  The <code>InterpolationKernels</code> package provides the <a href="../library/#InterpolationKernels.getweights"><code>getweights</code></a> method to efficiently compute interpolation weights for a given kernel and offset.</p><h2 id="Interpolation-principles-1"><a class="docs-heading-anchor" href="#Interpolation-principles-1">Interpolation principles</a><a class="docs-heading-anchor-permalink" href="#Interpolation-principles-1" title="Permalink"></a></h2><p>To explain how linear interpolation works, let us assume that we want to interpolate a source vector <code>src</code> using the kernel <code>ker: ‚Ñù ‚Üí ‚Ñù</code> to produce a continuous model function <code>mdl(x)</code> with <code>x ‚àà ‚Ñù</code> the continuous coordinate. Such a model writes:</p><pre><code class="language-none">mdl(x) = sum_{j ‚àà J} ker(x - j)*src[j]</code></pre><p>where <code>sum_{j ‚àà J}</code> denotes a sum over all indices <code>j</code> of <code>src</code>, that is <code>J = axes(src,1)</code>.  The above equation is a <strong>convolution</strong> of the source <code>src</code> by the kernel <code>ker</code>.  The model function is <code>mdl: ‚Ñù ‚Üí ùïÇ</code> where <code>ùïÇ</code> is the type of the product in the above sum.</p><p>If the kernel <code>ker</code> has a finite support of size <code>S ‚àà ‚Ñï</code>, there are at most <code>S</code> nonzero <code>ker(‚Ä¶)</code> terms in the sum.  Moreover, if <code>S</code> is much smaller than the length of <code>src</code> and to spare computations, it is worth rewriting the result of the interpolation as:</p><pre><code class="language-none">mdl(x) = sum_{k ‚àà 1:S} ker(x + p - k)*src[k - p]</code></pre><p>for some well chosen <code>p ‚àà ‚Ñ§</code> so that the sum over <code>k</code> accounts for all nonzero <code>ker(‚Ä¶)</code> terms.  This means that if <code>[kmin,kmax]</code> is the support of <code>ker(x)</code> (with <code>kmax = kmin + S</code>), then the following inequalities must hold:</p><pre><code class="language-none">kmin ‚â§ x + p - maximum(1:S) ‚â§ x + p - minimum(1:S) ‚â§ kmax</code></pre><p>where <code>minimum(1:S) ‚â° 1</code> and <code>maximum(1:S) ‚â° S</code> are the minimum and the maximum indices <code>k</code> in the sum <code>sum_{k ‚àà 1:S}</code>.  Re-arranging terms yields that <code>pmin ‚â§ p ‚â§ pmax</code> must hold with:</p><pre><code class="language-none">pmin = kmin - x + S
pmax = kmax - x + 1</code></pre><p>Note that the width of the interval <code>[pmin,pmax]</code> is <code>pmax - pmin = 1</code> since <code>kmax = kmin + S</code>, so the interval <code>[pmin,pmax]</code> always contains at least one integer and contains at most two integers when <code>pmin</code> (and <code>pmax</code>) is integer. This leaves 2 possibilities for choosing <code>p ‚àà [pmin,pmax] ‚à© ‚Ñ§</code>:</p><pre><code class="language-none">p = ceil(pmax) - 1 =  ceil(kmax - x)
p = floor(pmax)    = floor(kmax - x + 1)</code></pre><p>which are equivalent for most but not all values of <code>x</code> (they differ when <code>kmax-x</code> happens to be integer).  If <code>ker(kmin) = ker(kmax) = 0</code>, which should be the case if <code>ker(x)</code> is everywhere continuous, the choice between these two possibilities is irrelevant for the result of the interpolation.</p><p>Now introducing the so-called <strong>interpolation weights</strong> given by:</p><pre><code class="language-none">w[k] = ker(x + p - k)</code></pre><p>for <code>k ‚àà 1:S</code>, the interpolation can be rewritten as</p><pre><code class="language-none">dst[i] = sum_{k ‚àà 1:S} w[k]*src[k - p]</code></pre><p>which is a <strong>correlation</strong> of <code>w</code> and <code>src</code>.</p><h2 id="Interpolation-weights-1"><a class="docs-heading-anchor" href="#Interpolation-weights-1">Interpolation weights</a><a class="docs-heading-anchor-permalink" href="#Interpolation-weights-1" title="Permalink"></a></h2><p>In <code>InterpolationKernels</code> all kernels have a <strong>symmetric support</strong>, hence <code>kmin = -kmax</code> and <code>kmax = S/2</code>.  The interpolation weights are then given by:</p><pre><code class="language-none">w[k] = ker(x + ceil(S/2 - x) - k)</code></pre><p>for <code>k ‚àà 1:S</code> and assuming that <code>p = ceil(kmax - x)</code> has been chosen among the two possibilities.</p><p>Instead of computing the nonzero interpolation weights one by one by <code>S</code> calls to the kernel function, it may be beneficial to compute all weights in a row exploiting common sub-expressions.  This facility is provided by the kernels in <code>InterpolationKernels</code> and the interpolation weights for kernel <code>ker</code> can be computed by:</p><pre><code class="language-julia">w = getweights(ker, t)</code></pre><p>which yields an <code>S</code>-tuple <code>w</code> of weights with <code>S</code> the size of the support of the kernel <code>ker</code>.  To interpolate around position <code>x</code> (in fractional index units), the offset <code>t</code> is given by:</p><ul><li><p>if <code>S</code> is even:</p><pre><code class="language-julia">t = x - floor(x)</code></pre></li><li><p>if <code>S</code> is odd:</p><pre><code class="language-julia">t = x - floor(x + 1/2) = x - round(x)</code></pre></li></ul><p>The offset <code>t</code> is therefore in the range <code>[0,1]</code> for <code>S</code> even and in the range <code>[-1/2,+1/2]</code> for <code>S</code> odd.  The bounds being inclusive or not is irrelevant for the result (so the rounding direction does not matter).</p><p>One of the reasons of using these conventions is that the integer index:</p><pre><code class="language-julia">j = (iseven(S) ? floor(Int, x) : round(Int, x))</code></pre><p>such that <code>t = x - j</code> plays a central role in determining the indices of the entries in the interpolated array involved in the interpolation formula.</p><p>For developers who would like to implement other kernels than those provided by <code>InterpolationKernels</code>, it is necessary to derive the general formula for the weights as functions of the offset <code>t</code>.  Recalling that <code>w[k] = ker(v - k)</code> with <code>v = x + ceil(S/2 - x)</code>, the identity <code>ceil(-u) = -floor(u)</code> for any real <code>u</code> can be used to rewrite <code>v</code> as:</p><pre><code class="language-julia">v = x + ceil(S/2 - x)
  = x - floor(x - S/2)</code></pre><p>now 2 different cases must be considered depending on the parity of <code>S</code>:</p><ul><li><p>if <code>S</code> is even, then <code>S = 2c</code> with <code>c</code> integer, therefore <code>S/2 = c</code> and:</p><pre><code class="language-julia">v = x - floor(x - c) = x - floor(x) + c = t + c</code></pre></li><li><p>if <code>S</code> is odd, then <code>S = 2c - 1</code> with <code>c</code> integer, therefore <code>S/2 = c - 1/2</code> and:</p><pre><code class="language-julia">v = x - floor(x - c + 1/2) = x - floor(x + 1/2) + c = t + c</code></pre></li></ul><p>To summarize, the interpolations weights are simply given by:</p><pre><code class="language-julia">w[k] = ker(t + c - k)</code></pre><p>where:</p><pre><code class="language-julia">c = (S + 1) √∑ 2</code></pre><p>with <code>√∑</code> the integer division in Julia.</p><h2 id="Example:-fine-shifting-1"><a class="docs-heading-anchor" href="#Example:-fine-shifting-1">Example: fine shifting</a><a class="docs-heading-anchor-permalink" href="#Example:-fine-shifting-1" title="Permalink"></a></h2><p>Let us now assume that we want to compute:</p><pre><code class="language-none">dst[i] ‚âà src[i - r]</code></pre><p>for all indices <code>i ‚àà I</code> of the destination vector <code>dst</code> and some non-integer offset <code>r</code> where <code>‚âà</code> denotes the approximation by the interpolation model <code>mdl(x)</code> described above.  Hence <code>dst</code> is the result of performing a sub-sample shift of <code>src</code> by offset <code>r</code>.</p><p>Combining equations (that is just replace <code>x</code> by <code>i-r</code>) yields:</p><pre><code class="language-none">dst[i] = mdl(i - r)
       = sum_{j ‚àà J} ker(i - r - j)*src[j]</code></pre><p>In order to spare computations, we take <code>j = i - q + k</code> for some well chosen integer <code>q</code> and rewrite the interpolation as:</p><pre><code class="language-none">dst[i] = sum_{k ‚àà 1:R} ker(q - r - k)*src[i - q + k]</code></pre><p>we have to chose <code>q</code> such that the following inequalities hold:</p><pre><code class="language-none">kmin ‚â§ q - r - S ‚â§ q - r - 1 ‚â§ kmax</code></pre><p>with <code>[kmin,kmax]</code> the support of the kernel <code>ker</code> and <code>kmax - kmin = S</code> as before.  These inequalities are equivalent to:</p><pre><code class="language-none">(qmin = kmin + r + S) ‚â§ q ‚â§ (qmax = kmax + r + 1)</code></pre><p>as before <code>qmax - qmin = 1</code> and there are 2 possibilities for choosing <code>q</code>:</p><pre><code class="language-none">q = ceil(qmax) - 1 = ceil(kmax + r)
q = floor(qmax) = floor(kmax + 1 + r)</code></pre><p>Taking the second choice for <code>q</code> and assuming a symmetric support (hence <code>kmax = S/2</code>) yields:</p><pre><code class="language-none">q = floor(S/2 + 1 + r)
  = floor(c + r)</code></pre><p>where <code>c = 1 + S/2</code>.  The interpolation weights are now given by:</p><pre><code class="language-none">w[k] = ker(v - k)</code></pre><p>with:</p><pre><code class="language-none">v = q - r
  = floor(S/2 + 1 + r) - r</code></pre><p>Finally the result of fine shifting writes:</p><pre><code class="language-none">dst[i] = sum_{k ‚àà 1:R} w[k]*src[i - q + k]</code></pre><p>where the weights <code>w</code> and offset <code>q</code> do not depend on <code>i</code> and can thus be pre-computed resulting in very fast computations.  This is exploited by the <a href="https://github.com/emmt/FineShift.jl">FineShift</a> package.</p><p>If <em>flat</em> boundary conditions hold, we are assuming that <code>src[j] = src[1]</code> if <code>j ‚â§ 1</code> and <code>src[j] = src[n]</code> if <code>j ‚â• n</code> with <code>n = length(src)</code> the number of samples in <code>src</code>.  Then, if the shift <code>r</code> is too large (in magnitude) all <code>j = i + k - q</code> for <code>k = 1, ..., S</code> are below or above the limits in the interpolation formula.  This occurs when:</p><pre><code class="language-none">i + k - q ‚â§ 1  (‚àÄ i,k)  &lt;=&gt; i + S - 1 ‚â§ q  (‚àÄ i)  &lt;=&gt; S + m - 1 ‚â§ q
i + k - q ‚â• n  (‚àÄ i,k)  &lt;=&gt;         i ‚â• q  (‚àÄ i)  &lt;=&gt; 1 ‚â• q</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../boundaries/">¬´ Boundary conditions</a><a class="docs-footer-nextpage" href="../library/">Reference ¬ª</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 6 December 2020 13:25">Sunday 6 December 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
