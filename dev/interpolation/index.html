<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interpolation · Interpolation kernels for Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Interpolation kernels for Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../basics/">Basic usage</a></li><li><a class="tocitem" href="../kernels/">Kernels</a></li><li class="is-active"><a class="tocitem" href>Interpolation</a><ul class="internal"><li><a class="tocitem" href="#Interpolation-principles-1"><span>Interpolation principles</span></a></li><li><a class="tocitem" href="#Methods-and-structures-1"><span>Methods and structures</span></a></li><li><a class="tocitem" href="#Example:-fine-shifting-1"><span>Example: fine shifting</span></a></li></ul></li><li><a class="tocitem" href="../library/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interpolation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interpolation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/InterpolationKernels.jl/blob/master/docs/src/interpolation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interpolation-1"><a class="docs-heading-anchor" href="#Interpolation-1">Interpolation</a><a class="docs-heading-anchor-permalink" href="#Interpolation-1" title="Permalink"></a></h1><p>Interpolation kernels, as their name suggest, are designed for interpolating arrays.  The <code>InterpolationKernels</code> package provides the method <a href="../library/#InterpolationKernels.compute_offset_and_weights"><code>InterpolationKernels.compute_offset_and_weights</code></a> to efficiently compute interpolation weights for a given kernel and interpolating position.</p><h2 id="Interpolation-principles-1"><a class="docs-heading-anchor" href="#Interpolation-principles-1">Interpolation principles</a><a class="docs-heading-anchor-permalink" href="#Interpolation-principles-1" title="Permalink"></a></h2><p>To explain how linear interpolation works, let us assume that we want to interpolate a source vector <code>A ∈ 𝕂ⁿ</code> using the kernel <code>h: ℝ → ℝ</code> to produce a continuous model function <code>f(x)</code> with <code>x ∈ ℝ</code> the continuous coordinate. Such a model writes:</p><pre><code class="language-none">∀ x ∈ ℝ:    f(x) = sum_{k ∈ ℤ} h(x - k)*ℬ(A,k)</code></pre><p>where <code>sum_{k ∈ ℤ}</code> denotes a sum over all integers and <code>ℬ: 𝕂ⁿ×ℤ → 𝕂</code> implements the boundary conditions with <code>Sup(A)</code> the set of valid indices for <code>A</code>.  In Julia code, <code>Sup(A) = axes(A,1)</code> and <code>n = length(A)</code>.  The above equation is a <strong>discrete convolution</strong> of <code>A</code> by the kernel <code>h</code>.  The model function is <code>f: ℝ → 𝕂</code> where <code>𝕂</code> is the field of the values taken by the product in the above sum.  We make no restrictions for the boundary conditions except that the following always holds:</p><pre><code class="language-none">∀ k ∈ Sup(A):    ℬ(A,k) = A[k]</code></pre><p>For instance, <strong>flat boundaries</strong> are implemented by:</p><pre><code class="language-none">          / A[min(Sup(A))]  if k ≤ min(Sup(A))
ℬ(A,k) = |  A[max(Sup(A))]  if k ≥ max(Sup(A))
          \ A[k]            else</code></pre><p>Provided the kernel <code>h</code> has a finite size support, we can assume (without loss of generality) that the kernel support <code>Sup(h)</code> is enclosed in a right-open interval of nonzero integer width <code>s ∈ ℕ \ {0}</code>.  That is, there exists <code>a ∈ ℝ</code> such that <code>Sup(h) ⊂ [a,b)</code> with <code>b = a + s</code>.  In other words:</p><pre><code class="language-none">x &lt; a   or   x ≥ b    ⟹     h(x) = 0</code></pre><p>The indices <code>k ∈ ℤ</code> such that <code>h(x-k)</code> is not certainly zero are:</p><pre><code class="language-none">k ∈ ℤ, x-k ∈ [a,b)
⟺    k ∈ ℤ ∩ (x-b, x-a]
⟺    k ∈ ⟦⌊x-b+1⌋, ⌊x-a⌋⟧</code></pre><p>with <code>⌊…⌋</code> the floor function.  Since the objective is to have the smallest interval to restrict the number of terms in the discrete convolution, it may be better to enclose the kernel support in a left-open interval, that is <code>Sup(h) ⊂ (a,b]</code>, the set of indices <code>k</code> such that <code>h(x-k)</code> is not certainly zero is then given by:</p><pre><code class="language-none">k ∈ ℤ, x-k ∈ (a,b]
⟺    k ∈ ℤ ∩ [x-b, x-a)
⟺    k ∈ ⟦⌈x-b⌉, ⌈x-a-1⌉⟧</code></pre><p>with <code>⌈…⌉</code> the ceil function.  To summarize, the discrete convolution in the model <code>f(x)</code> can be limited to indices <code>k ∈ ⟦kmin(x),kmax(x)⟧</code> where:</p><pre><code class="language-none">kmin(x) = ⌊x-b+1⌋    if Sup(h) ⊂ [a,b)
          ⌈x-b⌉      if Sup(h) ⊂ (a,b]</code></pre><p>and <code>kmax(x) = kmin(x) + s - 1</code> (either of these above expressions can be chosen if <code>Sup(h) ⊂ (a,b)</code>).  The interpolation formula can finally be rewritten as:</p><pre><code class="language-none">∀ x ∈ ℝ:    f(x) = sum_{j ∈ jmin:jmax} w_j(x)*ℬ(A, l(x) + j)</code></pre><p>where <code>k = l(x) + j</code> and <code>w_j(x) = h(x-k)</code> for <code>j ∈ ⟦jmin,jmax⟧</code> account for all the non-zero terms of the sum in the original formula.  Hence <code>jmax = jmin+s-1</code> and:</p><pre><code class="language-none">  l(x) = kmin(x) - jmin
w_j(x) = h(x - l(x) - j)</code></pre><p>Note that <code>jmin ∈ ℤ</code> can be chosen as is the most convenient.  For instance, assuming Julia or Fortran indexing, one would choose <code>jmin = 1</code> and thus <code>l(x) = ⌊x-b⌋</code> if <code>Sup(h) ⊂ [a,b)</code>.</p><h2 id="Methods-and-structures-1"><a class="docs-heading-anchor" href="#Methods-and-structures-1">Methods and structures</a><a class="docs-heading-anchor-permalink" href="#Methods-and-structures-1" title="Permalink"></a></h2><h3 id="General-methods-1"><a class="docs-heading-anchor" href="#General-methods-1">General methods</a><a class="docs-heading-anchor-permalink" href="#General-methods-1" title="Permalink"></a></h3><p>The above developments suggest that, for any interpolation kernel <code>h</code> and interpolation coordinate <code>x</code>, we mostly need a function that yields the <strong>offset</strong> <code>l(x)</code> and the <strong>interpolation weights</strong> <code>w_j(x)</code> for all <code>j ∈ ⟦jmin,jmax⟧</code>.  This is exactly what is done by the method <code>compute_offset_and_weights</code> provided by the <code>InterpolationKernels</code> package. This method is called as:</p><pre><code class="language-julia">off, wgt = compute_offset_and_weights(h, x)</code></pre><p>with <code>h</code> the interpolation kernel, <code>x</code> the coordinate, <code>off = l(x)</code> the offset and <code>wgt</code> the <code>s</code>-tuple of interpolation weights given by <code>wgt[j] = w_j(x)</code>. In Julia, the first index of tuples is <code>1</code>, so we have <code>jmin = 1</code> and thus:</p><pre><code class="language-none">off = kmin(x) - 1 = ⌊x-b⌋          if Sup(h) ⊂ [a,b)
                    ⌈x-b⌉ - 1      if Sup(h) ⊂ (a,b]
wgt[j] = h(x - off - j)            for j = 1, 2, ..., s</code></pre><p>In order to compute the offset, the coordinate <code>x</code> but also the support of the kernel <code>h</code> must be known.  These are the reasons to have interpolation kernels in <code>InterpolationKernels</code> be defined as smart functions that know their support.</p><p>Assuming the following methods are available (they are indeed defined in <code>InterpolationKernels</code> but not exported):</p><pre><code class="language-julia">support(ker) ---&gt; sup # the kernel support `Sup(ker)`
length(sup) ----&gt; s   # the integer size of the kernel support
infimum(sup) ---&gt; a   # the least upper bound of the support `sup`
supremum(sup) --&gt; b   # the greatest lower bound of the support `sup`</code></pre><p>the offset <code>off</code> can be computed by (there are two cases to consider):</p><pre><code class="language-none">offset(sup::Support{T,S,&lt;:Bound,Open}, x::T) where {T,S} =
    floor(x - supremum(sup))       #  if Sup(ker) is ⊂ [a,b)
offset(sup::Support{T,S,Open,Closed}, x::T) where {T,S} =
    ceil(x - (supremum(sup) - 1))  #  if Sup(ker) is ⊂ (a,b]</code></pre><p>and a generic implementation of <code>compute_offset_and_weights</code> is given by:</p><pre><code class="language-julia">compute_offset_and_weights(ker::Kernel{T}, x::T) where {T} =
    compute_offset_and_weights(support(ker), ker, x)

function compute_offset_and_weights(sup::Support{T,S},
                                    ker::Kernel{T,S}, x::T) where {T,S}
    off = offset(sup, x)
    return off, ntuple(j -&gt; ker(x - off - j), Val(length(ker)))
end</code></pre><p>Of course <code>compute_offset_and_weights</code> is optimized for the most popular kernels in order to reduce the number of operations.  But the generic code above gives you the ideas.</p><h3 id="Symmetric-supports-1"><a class="docs-heading-anchor" href="#Symmetric-supports-1">Symmetric supports</a><a class="docs-heading-anchor-permalink" href="#Symmetric-supports-1" title="Permalink"></a></h3><p>For kernels with symmetric support, the following hold <code>a = -b</code> and <code>b = s/2</code>. The interpolation weights can be then expressed as:</p><pre><code class="language-none">wgt[j] = h(t - j)        for j ∈ 1-m:s-m</code></pre><p>with <code>m = (s+1)&gt;&gt;1</code> (that is the integer division of <code>s+1</code> by <code>2</code>) and:</p><pre><code class="language-none">t = x - floor(x)      if s is even
    x - round(x)      if s is odd</code></pre><p>and the offset is given by:</p><pre><code class="language-none">off = floor(x) - m      if s is even
      round(x) - m      if s is odd</code></pre><p>These expressions are used by <code>compute_offset_and_weights</code> for kernels with symmetric support because they may help reducing the number of operations (at least for splines) for computing interpolation weights.  In that case, the weights are computed by calling <code>compute_weights</code> with the kernel and the computed value of <code>t</code> (not <code>x</code>):</p><pre><code class="language-julia">wgt = compute_weights(k, t)</code></pre><p>When a new kernel is implemented, <code>compute_offset_and_weights</code> or, if the kernel has a symmetric support, <code>compute_weights</code> may be specialized to optimize computations.</p><h2 id="Example:-fine-shifting-1"><a class="docs-heading-anchor" href="#Example:-fine-shifting-1">Example: fine shifting</a><a class="docs-heading-anchor-permalink" href="#Example:-fine-shifting-1" title="Permalink"></a></h2><p>Let us now assume that we want to compute:</p><pre><code class="language-none">C[i] ≈ A[i - r]</code></pre><p>for all indices <code>i ∈ Sub(C)</code> of the destination vector <code>C</code> and some non-integer offset <code>r</code> where <code>≈</code> denotes the approximation by the interpolation model <code>f(x)</code> described above.  Hence <code>C</code> is the result of performing a sub-sample shift of <code>A</code> by offset <code>r</code>.</p><p>Combining equations (that is just replace <code>x</code> by <code>i-r</code> in the interpolation formula) yields:</p><pre><code class="language-none">C[i] = f(i - r)
     = sum_{j ∈ 1:s} h(i - r - l(i - r) - j)*ℬ(A, l(i - r) + j)</code></pre><p>From the definition of the offset <code>l(x)</code> it is obvious that:</p><pre><code class="language-none">∀ (r,i) ∈ ℝ×ℤ:    l(i - r) = i + l(-r) = i - k</code></pre><p>with:</p><pre><code class="language-none">k = -l(-r)</code></pre><p>Hence the interpolation writes:</p><pre><code class="language-none">C[i] = sum_{j ∈ 1:s} h(k - r - j)*ℬ(A, i - k + j)</code></pre><p>But as <code>v = k - r</code> is a constant that does not depend on <code>i</code>, the weights:</p><pre><code class="language-none">W[j] = h(k - r - j) = h(v - j)</code></pre><p>can be computed once for all indices <code>i</code> in the destination <code>B</code> to perform fine shifting by the following formula:</p><pre><code class="language-none">C[i] = sum_{j ∈ 1:s} W[j]*ℬ(A, i - k + j)</code></pre><p>which is a discrete correlation of <code>W</code> and <code>A</code>.  The weights <code>W</code> and the integer offset <code>k</code> do not depend on <code>i</code>, resulting in very fast computations. This is exploited by the <a href="https://github.com/emmt/FineShift.jl">FineShift</a> package.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../kernels/">« Kernels</a><a class="docs-footer-nextpage" href="../library/">Reference »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 27 March 2021 16:41">Saturday 27 March 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
