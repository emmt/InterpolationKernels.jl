<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kernels · Interpolation kernels for Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Interpolation kernels for Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../basics/">Basic usage</a></li><li class="is-active"><a class="tocitem" href>Kernels</a><ul class="internal"><li><a class="tocitem" href="#Rectangular-interpolation-kernel-1"><span>Rectangular interpolation kernel</span></a></li><li><a class="tocitem" href="#Triangular-interpolation-kernel-1"><span>Triangular interpolation kernel</span></a></li><li><a class="tocitem" href="#Quadratic-B-spline-1"><span>Quadratic B-spline</span></a></li><li><a class="tocitem" href="#Cubic-B-spline-1"><span>Cubic B-spline</span></a></li><li><a class="tocitem" href="#Cubic-splines-1"><span>Cubic splines</span></a></li><li><a class="tocitem" href="#Cardinal-cubic-splines-1"><span>Cardinal cubic splines</span></a></li><li><a class="tocitem" href="#Catmull-and-Rom-kernel-1"><span>Catmull &amp; Rom kernel</span></a></li><li><a class="tocitem" href="#Mitchell-and-Netravali-kernels-1"><span>Mitchell &amp; Netravali kernels</span></a></li><li><a class="tocitem" href="#Lanczos-re-sampling-kernels-1"><span>Lanczos re-sampling kernels</span></a></li></ul></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../library/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Kernels</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Kernels</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/InterpolationKernels.jl/blob/master/docs/src/kernels.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Kernels-1"><a class="docs-heading-anchor" href="#Kernels-1">Kernels</a><a class="docs-heading-anchor-permalink" href="#Kernels-1" title="Permalink"></a></h1><p><code>InterpolationKernels</code> provide the following kernels (<code>T</code> is an optional floating-point type):</p><table><tr><th style="text-align: left">Types</th><th style="text-align: center">Support</th><th style="text-align: center">Cardinal</th><th style="text-align: center">Parameters</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>BSpline{1,T}</code></td><td style="text-align: center">1</td><td style="text-align: center">yes</td><td style="text-align: center"></td><td style="text-align: left"><a href="#Rectangular-interpolation-kernel">rectangular B-spline</a></td></tr><tr><td style="text-align: left"><code>BSpline{2,T}</code></td><td style="text-align: center">2</td><td style="text-align: center">yes</td><td style="text-align: center"></td><td style="text-align: left"><a href="#Triangular-interpolation-kernel">linear B-spline</a></td></tr><tr><td style="text-align: left"><code>BSpline{3,T}</code></td><td style="text-align: center">3</td><td style="text-align: center">no</td><td style="text-align: center"></td><td style="text-align: left"><a href="#Quadratic-B-spline">quadratic B-spline</a></td></tr><tr><td style="text-align: left"><code>BSpline{4,T}</code></td><td style="text-align: center">4</td><td style="text-align: center">no</td><td style="text-align: center"></td><td style="text-align: left"><a href="#Cubic-B-spline">cubic B-spline</a></td></tr><tr><td style="text-align: left"><code>CubicSpline{T}</code></td><td style="text-align: center">4</td><td style="text-align: center">yes/no</td><td style="text-align: center"><code>a</code>, <code>b</code></td><td style="text-align: left"><a href="#Cubic-splines">cubic splines</a></td></tr><tr><td style="text-align: left"><code>CardinalCubicSpline{T}</code></td><td style="text-align: center">4</td><td style="text-align: center">yes</td><td style="text-align: center"><code>a</code></td><td style="text-align: left"><a href="#Cardinal-cubic-splines">cardinal cubic splines</a></td></tr><tr><td style="text-align: left"><code>CatmullRomSpline{T}</code></td><td style="text-align: center">4</td><td style="text-align: center">yes</td><td style="text-align: center"></td><td style="text-align: left"><a href="#Catmull-and-Rom-kernel">Catmull &amp; Rom kernel</a></td></tr><tr><td style="text-align: left"><code>MitchellNetravaliSpline{T}</code></td><td style="text-align: center">4</td><td style="text-align: center">yes/no</td><td style="text-align: center"><code>b</code>, <code>c</code></td><td style="text-align: left"><a href="#Mitchell-and-Netravali-kernels">Mitchell &amp; Netravali kernels</a></td></tr><tr><td style="text-align: left"><code>LanczosKernel{S,T}</code></td><td style="text-align: center"><code>S</code></td><td style="text-align: center">yes</td><td style="text-align: center"><code>S</code></td><td style="text-align: left"><a href="#Lanczos-re-sampling-kernels">Lanczos re-sampling kernels</a></td></tr></table><p>In this table, the <em>Cardinal</em> column indicates whether a kernel <code>ker(x)</code> is a cardinal function, that is <code>ker(k) = 0</code> for all integers <code>k</code> except that <code>ker(0) = 1</code> which makes such a kernel directly suitable for interpolation.</p><p>A <em>spline</em> is defined as a piecewise polynomial of given degree.  A <em>B-spline</em> of order <code>S</code> is a piecesiwe polynomial of degree <code>S - 1</code> which is everywhere nonnegative, an even and normalized function (its integral is equal to 1).</p><h2 id="Rectangular-interpolation-kernel-1"><a class="docs-heading-anchor" href="#Rectangular-interpolation-kernel-1">Rectangular interpolation kernel</a><a class="docs-heading-anchor-permalink" href="#Rectangular-interpolation-kernel-1" title="Permalink"></a></h2><p>The <strong>rectangular interpolation kernel</strong> (also known as <strong>box kernel</strong> or <strong>Fourier window</strong> or <strong>Dirichlet window</strong>) is the 1st order B-spline equals to <code>1</code> on <code>[-1/2,+1/2)</code>, and <code>0</code> elsewhere.  Interpolation by a rectangular spline amounts to interpolating by the nearest neighbor.</p><p>An instance of a rectangular interpolation kernel is created by:</p><pre><code class="language-julia">ker = BSpline{1,T}()</code></pre><p>where the floating-point type <code>T</code> is assumed to be <code>Float64</code> if omitted.</p><p>The expression <code>ker&#39;</code> yields the first derivative of the kernel <code>ker</code>.  An instance of a kernel implementing the first derivative of a rectangular interpolation kernel may be directly created by:</p><pre><code class="language-julia"> BSplinePrime{1,T}()</code></pre><p>where, again, the floating-point type parameter <code>T</code> my be omitted.</p><h2 id="Triangular-interpolation-kernel-1"><a class="docs-heading-anchor" href="#Triangular-interpolation-kernel-1">Triangular interpolation kernel</a><a class="docs-heading-anchor-permalink" href="#Triangular-interpolation-kernel-1" title="Permalink"></a></h2><p>The <strong>triangular interpolation kernel</strong> linear spline (also known as <strong>triangle kernel</strong> or <strong>Bartlett window</strong> or <strong>Fejér window</strong>) is the 2nd order B-spline defined by:</p><pre><code class="language-none">ker(x) = 1 - |x|       if |x| ≤ 1
         0             if |x| ≥ 1</code></pre><p>An instance of a triangular interpolation kernel is created by:</p><pre><code class="language-julia">ker = BSpline{2,T}()</code></pre><p>where the floating-point type <code>T</code> is assumed to be <code>Float64</code> if omitted.</p><p>The expression <code>ker&#39;</code> yields the first derivative of the kernel <code>ker</code>.  An instance of a kernel implementing the first derivative of a triangular interpolation kernel may be directly created by:</p><pre><code class="language-julia"> BSplinePrime{2,T}()</code></pre><p>where, again, the floating-point type parameter <code>T</code> my be omitted.</p><h2 id="Quadratic-B-spline-1"><a class="docs-heading-anchor" href="#Quadratic-B-spline-1">Quadratic B-spline</a><a class="docs-heading-anchor-permalink" href="#Quadratic-B-spline-1" title="Permalink"></a></h2><p>The <strong>quadratic B-spline</strong> is the 3rd order B-spline defined by:</p><pre><code class="language-none">ker(x) = 3/4 - x^2                   if |x| ≤ 1/2
         (1/2)*(|x| - 3/2)^2         if |x| ≤ 3/2
         0                           if |x| ≥ 3/2</code></pre><p>An instance of a quadratic B-spline is created by:</p><pre><code class="language-julia">BSpline{3,T}()</code></pre><p>where the floating-point type <code>T</code> is assumed to be <code>Float64</code> if omitted.</p><p>The expression <code>ker&#39;</code> yields the first derivative of the kernel <code>ker</code>.  An instance of a kernel implementing the first derivative of a quadratic B-spline may be directly created by:</p><pre><code class="language-julia"> BSplinePrime{3,T}()</code></pre><p>where, again, the floating-point type parameter <code>T</code> my be omitted.</p><h2 id="Cubic-B-spline-1"><a class="docs-heading-anchor" href="#Cubic-B-spline-1">Cubic B-spline</a><a class="docs-heading-anchor-permalink" href="#Cubic-B-spline-1" title="Permalink"></a></h2><p>The 4th order (cubic) B-spline kernel (also known as <strong>Parzen window</strong> or as <strong>de la Vallée Poussin window</strong>) is defined by:</p><pre><code class="language-none">ker(x) = (|x|/2 - 1)*|x|^2 + 2/3     if |x| ≤ 1
         (1/6)*(2 - |x|)^3           if 1 ≤ |x| ≤ 2
         0                           if |x| ≥ 2</code></pre><p>An of a cubic B-spline is created by:</p><pre><code class="language-julia">BSpline{4,T}()</code></pre><p>where the floating-point type <code>T</code> is assumed to be <code>Float64</code> if omitted.</p><p>The cubic B-spline is a C² continuous function (its derivatives up to the second one are everywhere continuous).  The expression <code>ker&#39;</code> yields the first derivative of the kernel <code>ker</code>.  An instance of a kernel implementing the first derivative of a cubic B-spline may be directly created by:</p><pre><code class="language-julia"> BSplinePrime{4,T}()</code></pre><p>where, again, the floating-point type parameter <code>T</code> my be omitted.</p><h2 id="Cubic-splines-1"><a class="docs-heading-anchor" href="#Cubic-splines-1">Cubic splines</a><a class="docs-heading-anchor-permalink" href="#Cubic-splines-1" title="Permalink"></a></h2><p>An instance of the familily of cubic spline kernels is created by:</p><pre><code class="language-julia">ker = CubicSpline{T}(a, b)</code></pre><p>and is defined by:</p><pre><code class="language-none">ker(x) = ((2 + a - 6b)*|x| +  (9b - a - 3))*x^2 + (1 - 2b)  if |x| ≤ 1
         ((a + 2b)*|x| - (a + b))*(|x| - 2)^2               if |x| ≤ 2
         0                                                  if |x| ≥ 2</code></pre><p>The parameters <code>a = ker&#39;(1)</code> and <code>b = ker(1)</code> are the slope and the value of the function <code>ker(x)</code> at <code>x = 1</code>.  The type parameter <code>T</code> is the floating-point type for computations <code>T</code>, it may be omitted in which case it is guessed from the types of <code>a</code> and <code>b</code> as <code>T = float(promote(typeof(a), typeof(b)))</code>.</p><p>A cubic spline kernel is at least C¹ continuous, the expression <code>ker&#39;</code> yields a kernel instance implementing the 1st derivative of the generic cubic spline <code>ker</code>.  Such a derivative may be directly built by calling:</p><pre><code class="language-julia">CubicSplinePrime{T}(a, b)</code></pre><p>Depending on the values of the parameters <code>a</code> and <code>b</code>, more specific cubic spline kernels can be emulated:</p><ul><li><p><code>CubicSpline{T}(-1/2,1/6)</code> yields a cubic B-spline as built by <code>BSpline{4,T}()</code>.</p></li><li><p><code>CubicSpline{T}(a,0)</code> yields a cardinal cubic spline as built by <code>CardinalCubicSpline{T}(a)</code>.</p></li><li><p><code>CubicSpline{T}(-1/2,0)</code> yields a Catmull-Rom kernel as built by <code>CatmullRomSpline{T}()</code>.</p></li><li><p><code>CubicSpline{T}(-b/2-c,b/6)</code> yields Mitchell &amp; Netravali cubic spline as built by <code>MitchellNetravaliSpline{T}(b,c)</code>.</p></li></ul><p>Calling <a href="../library/#InterpolationKernels.BSpline"><code>BSpline</code></a>, <a href="../library/#InterpolationKernels.CatmullRomSpline"><code>CatmullRomSpline</code></a>, <a href="../library/#InterpolationKernels.CardinalCubicSpline"><code>CardinalCubicSpline</code></a>, or <a href="../library/#InterpolationKernels.MitchellNetravaliSpline"><code>MitchellNetravaliSpline</code></a> to build these more specialized cubic splines may yield more efficient kernels as computations involve more simple expressions.  Instances of <code>CubicSpline</code> are however very well optimized and, in practice, they may be as fast or even faster than their more specialized counterparts.  If ultimate performances matter, the <a href="https://github.com/JuliaCI/BenchmarkTools.jl"><code>BenchmarkTools</code></a> package may helps you to decide which kernel to choose for a given machine.</p><h2 id="Cardinal-cubic-splines-1"><a class="docs-heading-anchor" href="#Cardinal-cubic-splines-1">Cardinal cubic splines</a><a class="docs-heading-anchor-permalink" href="#Cardinal-cubic-splines-1" title="Permalink"></a></h2><p>Keys kernels form the family of cardinal cubic splines.  A cardinal cubic spline is defined by:</p><pre><code class="language-none">ker(x) = 1 - (a + 3)*x^2 + (a + 2)*|x|^3      if |x| ≤ 1
         -4a + 8a*|x| - 5a*x^2 + a*|x|^3      if 1 ≤ |x| ≤ 2
         0                                    if |x| ≥ 2</code></pre><p>These kernels are C¹ continuous piecewise normalized cardinal cubic spline which depend on one parameter <code>a = ker&#39;(1)</code> the slope of the function <code>ker(x)</code> at <code>x = 1</code>.</p><p>To create an instance of a cardinal cubic spline with parameter <code>a</code>, call:</p><pre><code class="language-julia">ker = CardinalCubicSpline{T}(a)</code></pre><p>where <code>T</code> is the floating-point type for computations.  If omitted, <code>T</code> is <code>typeof(a)</code> if it is <code>Float16</code>, <code>Float32</code>, <code>Float64</code>, or <code>BigFloat</code> and <code>Float64</code> otherwise.</p><p>The expression <code>ker&#39;</code> yields the first derivative of the cardinal cubic spline <code>ker</code>.  An instance of the first derivative of such a kernel can also be directly created by:</p><pre><code class="language-julia">CardinalCubicSplinePrime{T}(a)</code></pre><p>with the same default for <code>T</code> if this parameter is omitted.</p><h3 id="References-1"><a class="docs-heading-anchor" href="#References-1">References</a><a class="docs-heading-anchor-permalink" href="#References-1" title="Permalink"></a></h3><ul><li>Keys, Robert, G., &quot;<em>Cubic Convolution Interpolation for Digital Image Processing</em>&quot;, IEEE Trans. Acoustics, Speech, and Signal Processing, Vol. ASSP-29, No. 6, December 1981, pp. 1153-1160.</li></ul><h2 id="Catmull-and-Rom-kernel-1"><a class="docs-heading-anchor" href="#Catmull-and-Rom-kernel-1">Catmull &amp; Rom kernel</a><a class="docs-heading-anchor-permalink" href="#Catmull-and-Rom-kernel-1" title="Permalink"></a></h2><p>The Catmull-Rom kernel is a cardinal piecewise cubic spline defined by:</p><pre><code class="language-none">ker(x) = ((3/2)*|x| - (5/2))*x^2 + 1             if |x| ≤ 1
         (((5/2) - (1/2)*|x|)*|x| - 4)*|x| + 2   if 1 ≤ |x| ≤ 2
         0                                       if |x| ≥ 2</code></pre><p>Being a cardinal function, the Catmull-Rom kernel is suitable for interpolation.  Its derivative is given by:</p><pre><code class="language-none">ker′(x) = ((9/2)*|x| - 5)*x                      if a = |x| ≤ 1
          (5 - (3/2)*|x|)*x - 4*sign(x)          if 1 ≤ |x| ≤ 2
          0                                      if |x| ≥ 2</code></pre><p>To create an instance of a Catmull-Rom interpolation kernel, call</p><pre><code class="language-julia">ker = CatmullRomSpline{T}()</code></pre><p>where the floating-point type <code>T</code> is assumed to be <code>Float64</code> if omitted.  To create an instance of the derivative of a Catmull-Rom interpolation kernel, call one of:</p><pre><code class="language-julia">kerp = ker&#39;
kerp = CatmullRomSplinePrime{T}()</code></pre><h2 id="Mitchell-and-Netravali-kernels-1"><a class="docs-heading-anchor" href="#Mitchell-and-Netravali-kernels-1">Mitchell &amp; Netravali kernels</a><a class="docs-heading-anchor-permalink" href="#Mitchell-and-Netravali-kernels-1" title="Permalink"></a></h2><p>Mitchell &amp; Netravali kernels are a specific form of the family of cubic splines.  These kernels are parametric piecewise cubic splines defined by:</p><pre><code class="language-none">ker(x) = (1/6)*(((12 - 9b - 6c)*|x| - 18 + 12b + 6c)*x^2 + (6 - 2b))   if |x| ≤ 1
         (1/6)*(2b + 6c - (b + 6c)*|x|)*(2 - |x|)^2                    if 1 ≤ |x| ≤ 2
         0                                                             if |x| ≥ 2</code></pre><p>Instances of a Mitchell &amp; Netravali kernel and of its derivative are respectively created by:</p><pre><code class="language-julia">MitchellNetravaliSpline{T}(b, c)
MitchellNetravaliSplinePrime{T}(b, c)</code></pre><p>with <code>T</code> the floating-point type for computations.  If <code>T</code> is omitted but <code>b</code> and <code>c</code> are specified, <code>T</code> is deduced from the floating-point type of <code>b</code> and <code>c</code>.  If <code>b</code> and <code>c</code> are omitted, <code>(b,c) = (1/3,1/3)</code> is assumed as recommended by Mitchell &amp; Netravali.  If <code>T</code> is omitted and <code>b</code> and <code>c</code> are omitted or both integers, <code>T = Float64</code> is assumed.</p><p>Whatever the values of the parameters <code>b</code> and <code>c</code>, Mitchell &amp; Netravali kernels are normalized and even functions of class C¹ (these kernels and their first derivatives are continuous).  The expression <code>ker&#39;</code> yields the first derivative of a Mitchell &amp; Netravali kernel <code>ker</code>.</p><p>Taking <code>b = 0</code> yields Keys&#39;s family of kernels and is a sufficient and necessary condition to have Mitchell &amp; Netravali kernels be cardinal functions.</p><p>Using the constraint: <code>b + 2c = 1</code> yields a cubic filter with, at least, quadratic order approximation.</p><p>Some specific values of <code>(b,c)</code> yield other well known kernels:</p><pre><code class="language-none">(b,c) = (1,0)      --&gt; cubic B-spline
(b,c) = (0,-a)     --&gt; Keys&#39;s cardinal cubic spline CardinalCubicSpline(a)
(b,c) = (0,1/2)    --&gt; Catmull-Rom kernel CatmullRomSpline()
(b,c) = (b,0)      --&gt; Duff&#39;s tensioned B-spline
(b,c) = (6β,-α-3β) --&gt; generic cubic spline CubicSpline(α,β)
(b,c) = (1/3,1/3)  --&gt; recommended by Mitchell-Netravali</code></pre><p>This family of kernels and their derivatives is implemented as instances of <code>CubicSpline</code> and <code>CubicSplinePrime</code> using the following property:</p><pre><code class="language-julia">MitchellNetravaliSpline{T}(b, c) = CubicSpline{T}(-b/2 - c, b/6)</code></pre><h3 id="References-2"><a class="docs-heading-anchor" href="#References-2">References</a><a class="docs-heading-anchor-permalink" href="#References-2" title="Permalink"></a></h3><ul><li>Mitchell &amp; Netravali, &quot;<em>Reconstruction Filters in Computer Graphics</em>&quot;, in Computer Graphics, Vol. 22, Num. 4 (1988) <a href="http://www.cs.utexas.edu/users/fussell/courses/cs384g/lectures/mitchell/Mitchell.pdf">pdf</a>.</li></ul><h2 id="Lanczos-re-sampling-kernels-1"><a class="docs-heading-anchor" href="#Lanczos-re-sampling-kernels-1">Lanczos re-sampling kernels</a><a class="docs-heading-anchor-permalink" href="#Lanczos-re-sampling-kernels-1" title="Permalink"></a></h2><p>The Lanczos re-sampling kernels are defined by:</p><pre><code class="language-none">ker(x) = (S/2π²)*sin(π*x)*sin(2π*x/S)/x^2   if |x| ≤ S/2
         0                                  if |x| ≥ S/2</code></pre><p>The Lanczos re-sampling kernels are even cardinal functions which tend to be normalized for large support size (see <a href="https://en.wikipedia.org/wiki/Lanczos_resampling">this Wikipedia page</a>).</p><p>To create an instance of a Lanczos re-sampling kernel of support size <code>S</code> (which must be even), call:</p><pre><code class="language-julia">LanczosKernel{S,T}()</code></pre><p>where the floating-point type <code>T</code> is assumed to be <code>Float64</code> if omitted.</p><p>The expression <code>ker&#39;</code> yields the first derivative of a Lanczos re-sampling kernel <code>ker</code>.  An instance of a kernel implementing the first derivative of a Lanczos re-sampling kernel can also be directly created by:</p><pre><code class="language-julia">LanczosKernelPrime{S,T}()</code></pre><p>where, again, it is possible to omit the floating-point type parameter <code>T</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basics/">« Basic usage</a><a class="docs-footer-nextpage" href="../interpolation/">Interpolation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 28 March 2021 11:59">Sunday 28 March 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
