var documenterSearchIndex = {"docs":
[{"location":"kernels/#Kernels-1","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"InterpolationKernels provide the following kernels (T is an optional floating-point type):","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Types Support Cardinal Parameters Description\nBSpline{1,T} 1 yes  rectangular B-spline\nBSpline{2,T} 2 yes  linear B-spline\nBSpline{3,T} 3 no  quadratic B-spline\nBSpline{4,T} 4 no  cubic B-spline\nCubicSpline{T} 4 yes/no a, b cubic splines\nCardinalCubicSpline{T} 4 yes a cardinal cubic splines\nCatmullRomSpline{T} 4 yes  Catmull & Rom kernel\nMitchellNetravaliSpline{T} 4 yes/no b, c Mitchell & Netravali kernels\nLanczosKernel{S,T} S yes S Lanczos re-sampling kernels","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"In this table, the Cardinal column indicates whether a kernel ker(x) is a cardinal function, that is ker(k) = 0 for all integers k except that ker(0) = 1 which makes such a kernel directly suitable for interpolation.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"A spline is defined as a piecewise polynomial of given degree.  A B-spline of order S is a piecesiwe polynomial of degree S - 1 which is everywhere nonnegative, an even and normalized function (its integral is equal to 1).","category":"page"},{"location":"kernels/#Rectangular-interpolation-kernel-1","page":"Kernels","title":"Rectangular interpolation kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The rectangular interpolation kernel (also known as box kernel or Fourier window or Dirichlet window) is the 1st order B-spline equals to 1 on [-1/2,+1/2), and 0 elsewhere.  An instance of a rectangular interpolation kernel is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = BSpline{1,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of the kernel ker.  An instance of a kernel implementing the first derivative of a rectangular interpolation kernel may be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":" BSplinePrime{1,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where, again, the floating-point type parameter T my be omitted.","category":"page"},{"location":"kernels/#Triangular-interpolation-kernel-1","page":"Kernels","title":"Triangular interpolation kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The triangular interpolation kernel linear spline (also known as triangle kernel or Bartlett window or Fejér window) is the 2nd order B-spline defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = 1 - |x|       if |x| ≤ 1\n         0             if |x| ≥ 1","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"An instance of a triangular interpolation kernel is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = BSpline{2,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of the kernel ker.  An instance of a kernel implementing the first derivative of a triangular interpolation kernel may be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":" BSplinePrime{2,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where, again, the floating-point type parameter T my be omitted.","category":"page"},{"location":"kernels/#Quadratic-B-spline-1","page":"Kernels","title":"Quadratic B-spline","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The quadratic B-spline is the 3rd order B-spline defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = 3/4 - x^2                   if |x| ≤ 1/2\n         (1/2)*(|x| - 3/2)^2         if |x| ≤ 3/2\n         0                           if |x| ≥ 3/2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"An instance of a quadratic B-spline is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"BSpline{3,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of the kernel ker.  An instance of a kernel implementing the first derivative of a quadratic B-spline may be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":" BSplinePrime{3,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where, again, the floating-point type parameter T my be omitted.","category":"page"},{"location":"kernels/#Cubic-B-spline-1","page":"Kernels","title":"Cubic B-spline","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The 4th order (cubic) B-spline kernel (also known as Parzen window or as de la Vallée Poussin window) is defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = (|x|/2 - 1)*|x|^2 + 2/3     if |x| ≤ 1\n         (1/6)*(2 - |x|)^3           if 1 ≤ |x| ≤ 2\n         0                           if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"An of a cubic B-spline is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"BSpline{4,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The cubic B-spline is a C² continuous function (its derivatives up to the second one are everywhere continuous).  The expression ker' yields the first derivative of the kernel ker.  An instance of a kernel implementing the first derivative of a cubic B-spline may be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":" BSplinePrime{4,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where, again, the floating-point type parameter T my be omitted.","category":"page"},{"location":"kernels/#Cubic-splines-1","page":"Kernels","title":"Cubic splines","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"An instance of the familily of cubic spline kernels is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = CubicSpline{T}(a, b)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"and is defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = ((2 + a - 6b)*|x| +  (9b - a - 3))*x^2 + (1 - 2b)  if |x| ≤ 1\n         ((a + 2b)*|x| - (a + b))*(|x| - 2)^2               if |x| ≤ 2\n         0                                                  if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The parameters a = ker'(1) and b = ker(1) are the slope and the value of the function ker(x) at x = 1.  The type parameter T is the floating-point type for computations T, it may be omitted in which case it is guessed from the types of a and b as T = float(promote(typeof(a), typeof(b))).","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"A cubic spline kernel is at least C¹ continuous, the expression ker' yields a kernel instance implementing the 1st derivative of the generic cubic spline ker.  Such a derivative may be directly built by calling:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"CubicSplinePrime{T}(a, b)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Depending on the values of the parameters a and b, more specific cubic spline kernels can be emulated:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"CubicSpline{T}(-1/2,1/6) yields a cubic B-spline as built by BSpline{4,T}().\nCubicSpline{T}(a,0) yields a cardinal cubic spline as built by CardinalCubicSpline{T}(a).\nCubicSpline{T}(-1/2,0) yields a Catmull-Rom kernel as built by CatmullRomSpline{T}().\nCubicSpline{T}(-b/2-c,b/6) yields Mitchell & Netravali cubic spline as built by MitchellNetravaliSpline{T}(b,c).","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Calling BSpline, CatmullRomSpline, CardinalCubicSpline, or MitchellNetravaliSpline to build these more specialized cubic splines may yield more efficient kernels as computations involve more simple expressions.  Instances of CubicSpline are however very well optimized and, in practice, they may be as fast or even faster than their more specialized counterparts.  If ultimate performances matter, the BenchmarkTools package may helps you to decide which kernel to choose for a given machine.","category":"page"},{"location":"kernels/#Cardinal-cubic-splines-1","page":"Kernels","title":"Cardinal cubic splines","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Keys kernels form the family of cardinal cubic splines.  A cardinal cubic spline is defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = 1 - (a + 3)*x^2 + (a + 2)*|x|^3      if |x| ≤ 1\n         -4a + 8a*|x| - 5a*x^2 + a*|x|^3      if 1 ≤ |x| ≤ 2\n         0                                    if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"These kernels are C¹ continuous piecewise normalized cardinal cubic spline which depend on one parameter a = ker'(1) the slope of the function ker(x) at x = 1.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a cardinal cubic spline with parameter a, call:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = CardinalCubicSpline{T}(a)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where T is the floating-point type for computations.  If omitted, T is typeof(a) if it is Float16, Float32, Float64, or BigFloat and Float64 otherwise.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of the cardinal cubic spline ker.  An instance of the first derivative of such a kernel can also be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"CardinalCubicSplinePrime{T}(a)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"with the same default for T if this parameter is omitted.","category":"page"},{"location":"kernels/#References-1","page":"Kernels","title":"References","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Keys, Robert, G., \"Cubic Convolution Interpolation for Digital Image Processing\", IEEE Trans. Acoustics, Speech, and Signal Processing, Vol. ASSP-29, No. 6, December 1981, pp. 1153-1160.","category":"page"},{"location":"kernels/#Catmull-and-Rom-kernel-1","page":"Kernels","title":"Catmull & Rom kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The Catmull-Rom kernel is a cardinal piecewise cubic spline defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = ((3/2)*|x| - (5/2))*x^2 + 1             if |x| ≤ 1\n         (((5/2) - (1/2)*|x|)*|x| - 4)*|x| + 2   if 1 ≤ |x| ≤ 2\n         0                                       if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Being a cardinal function, the Catmull-Rom kernel is suitable for interpolation.  Its derivative is given by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker′(x) = ((9/2)*|x| - 5)*x                      if a = |x| ≤ 1\n          (5 - (3/2)*|x|)*x - 4*sign(x)          if 1 ≤ |x| ≤ 2\n          0                                      if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a Catmull-Rom interpolation kernel, call","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = CatmullRomSpline{T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.  To create an instance of the derivative of a Catmull-Rom interpolation kernel, call one of:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"kerp = ker'\nkerp = CatmullRomSplinePrime{T}()","category":"page"},{"location":"kernels/#Mitchell-and-Netravali-kernels-1","page":"Kernels","title":"Mitchell & Netravali kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Mitchell & Netravali kernels are a specific form of the family of cubic splines.  These kernels are parametric piecewise cubic splines defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = (1/6)*(((12 - 9b - 6c)*|x| - 18 + 12b + 6c)*x^2 + (6 - 2b))   if |x| ≤ 1\n         (1/6)*(2b + 6c - (b + 6c)*|x|)*(2 - |x|)^2                    if 1 ≤ |x| ≤ 2\n         0                                                             if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Instances of a Mitchell & Netravali kernel and of its derivative are respectively created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"MitchellNetravaliSpline{T}(b, c)\nMitchellNetravaliSplinePrime{T}(b, c)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"with T the floating-point type for computations.  If T is omitted but b and c are specified, T is deduced from the floating-point type of b and c.  If b and c are omitted, (b,c) = (1/3,1/3) is assumed as recommended by Mitchell & Netravali.  If T is omitted and b and c are omitted or both integers, T = Float64 is assumed.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Whatever the values of the parameters b and c, Mitchell & Netravali kernels are normalized and even functions of class C¹ (these kernels and their first derivatives are continuous).  The expression ker' yields the first derivative of a Mitchell & Netravali kernel ker.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Taking b = 0 yields Keys's family of kernels and is a sufficient and necessary condition to have Mitchell & Netravali kernels be cardinal functions.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Using the constraint: b + 2c = 1 yields a cubic filter with, at least, quadratic order approximation.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Some specific values of (b,c) yield other well known kernels:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"(b,c) = (1,0)      --> cubic B-spline\n(b,c) = (0,-a)     --> Keys's cardinal cubic spline CardinalCubicSpline(a)\n(b,c) = (0,1/2)    --> Catmull-Rom kernel CatmullRomSpline()\n(b,c) = (b,0)      --> Duff's tensioned B-spline\n(b,c) = (6β,-α-3β) --> generic cubic spline CubicSpline(α,β)\n(b,c) = (1/3,1/3)  --> recommended by Mitchell-Netravali","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"This family of kernels and their derivatives is implemented as instances of CubicSpline and CubicSplinePrime using the following property:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"MitchellNetravaliSpline{T}(b, c) = CubicSpline{T}(-b/2 - c, b/6)","category":"page"},{"location":"kernels/#References-2","page":"Kernels","title":"References","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Mitchell & Netravali, \"Reconstruction Filters in Computer Graphics\", in Computer Graphics, Vol. 22, Num. 4 (1988) pdf.","category":"page"},{"location":"kernels/#Lanczos-re-sampling-kernels-1","page":"Kernels","title":"Lanczos re-sampling kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The Lanczos re-sampling kernels are defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = (S/2π²)*sin(π*x)*sin(2π*x/S)/x^2   if |x| ≤ S/2\n         0                                  if |x| ≥ S/2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The Lanczos re-sampling kernels are even cardinal functions which tend to be normalized for large support size (see this Wikipedia page).","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a Lanczos re-sampling kernel of support size S (which must be even), call:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"LanczosKernel{S,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of a Lanczos re-sampling kernel ker.  An instance of a kernel implementing the first derivative of a Lanczos re-sampling kernel can also be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"LanczosKernelPrime{S,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where, again, it is possible to omit the floating-point type parameter T.","category":"page"},{"location":"library/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"The following provides detailled documentation about types and methods provided by the InterpolationKernels package.  This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"library/#Methods-1","page":"Reference","title":"Methods","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"iscardinal\nisnormalized\nInterpolationKernels.brief\nInterpolationKernels.compute_weights\nInterpolationKernels.compute_offset_and_weights","category":"page"},{"location":"library/#InterpolationKernels.iscardinal","page":"Reference","title":"InterpolationKernels.iscardinal","text":"iscardinal(ker)\n\nyields whether the kernel ker is zero for non-zero integer arguments. Cardinal kernels are directly suitable for interpolation.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.isnormalized","page":"Reference","title":"InterpolationKernels.isnormalized","text":"isnormalized(ker)\n\nyields whether the kernel ker has the partition of unity property.  That is, the sum of the values computed by the kernel ker on a unit spaced grid is equal to one.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.brief","page":"Reference","title":"InterpolationKernels.brief","text":"InterpolationKernels.brief(ker)\n\nyields a brief description of the kernel type or instance ker.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.compute_weights","page":"Reference","title":"InterpolationKernels.compute_weights","text":"compute_weights(ker, t) -> wgt\n\ncomputes the interpolation weights returned by InterpolationKernels.compute_offset_and_weights for kernel ker. Assuming interpolation is performed at at position x, argument t is given by:\n\n t = x - floor(x)     if length(ker) is even\n t = x - round(x)     if length(ker) is odd\n\nThe returned weights are then:\n\n wgt = ntuple(i -> ker(t + k - i), length(ker))\n\nwhere k = (length(ker) + 1) >> 1 (i.e., integer division of length(ker)+1 by 2).  These conventions have been adopted so that, by specializing the compute_weights method, computing the length(ker) weights at the same time may be done in much fewer operations than calling ker as a function for each weight.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.compute_offset_and_weights","page":"Reference","title":"InterpolationKernels.compute_offset_and_weights","text":"compute_offset_and_weights(ker, x) -> off, wgt\n\nyields the index offset off and the weights wgt to interpolate with kernel ker at position x in fractional index units.  The offset is a scalar and the weights are an n-tuple with n = length(ker) the size of the support of the kernel, all returned values have the same floating point type eltype(ker) as the kernel.\n\nNot taking into account boundary conditions, interpolating a vector A at position x would then write:\n\noff, wgt = compute_offset_and_weights(ker, x)\nk = Int(off) # here boundary conditions should be imposed\nresult = wgt[1]*A[k+1] + ... + wgt[n]*A[k+n]\n\nNote that 1-based indexing is assumed by compute_offset_and_weights to interpret the position x and compute the offset off.  If this is not the case, the code should be:\n\nj1 = first(axes(A,1)) # first index in A\noff, wgt = compute_offset_and_weights(ker, x - (j1 - 1))\nk = Int(off) + (j1 - 1) # here boundary conditions should be imposed\nresult = wgt[1]*A[k+1] + ... + wgt[n]*A[k+n]\n\nwhere expression x - (j1 - 1) is assuming that the position x is in fractional index for A, that is x = j1 at the first entry of A.\n\nSee InterpolationKernels.compute_weights to only compute the interpolation weights.\n\n\n\n\n\n","category":"function"},{"location":"library/#Kernels-1","page":"Reference","title":"Kernels","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"Kernel","category":"page"},{"location":"library/#InterpolationKernels.Kernel","page":"Reference","title":"InterpolationKernels.Kernel","text":"Interpolation Kernels\n\nAn interpolation kernel Kernel{T,S} is parametrized by the floating-point type T of its coefficients and by the integer size S of its support.  For efficiency reasons, only kernels with (small) finite size supports are implemented.\n\nA kernel ker is a callable object which may be used as a function with a real argument:\n\nker(x::Real)\n\nyields kernel value at offset x.  Whatever the type of x, ker(x) is always of type T = eltype(ker) the floating-point type associated with ker. All kernel supports are symmetric; that is ker(x) is zero if abs(x) > S/2 with S = length(ker) the size of the kernel support.\n\nKernel floating-point type conversion\n\nCalled as a function with a real argument, a given kernel returns a value of its associated floating-point type.  This has been chosen to have fast interpolation methods.  Converting a kernel ker to use floating-point type T is simply done by one of:\n\nT(ker)\nKernel{T}(ker)\nconvert(Kernel{T}, ker)\n\nBeware that changing the floating-point type may lead to a loss of precision if the kernel has numerical parameters.\n\nCommon methods\n\nA few common methods are specialized for any interpolation kernel ker:\n\neltype(ker) -> T\n\nyields the floating-point type for calculations,\n\nlength(ker) -> S\n\nyield the size the support of ker which is also the number of neighbors involved in an interpolation by this kernel,\n\nvalues(ker)\n\nyields a tuple of the parameters of ker such that an identical instance can be built by:\n\ntypeof(ker)(values(ker)...)\n\nfinally:\n\ncompute_offset_and_weights(ker, x) -> off, (w1, w2, ..., wS)\n\nyields the offset off and an S-tuple of interpolation weights to interpolate an array at coordinate x (in fractional index units).\n\n\n\n\n\n","category":"type"},{"location":"library/#B-splines-1","page":"Reference","title":"B-splines","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"BSpline\nBSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.BSpline","page":"Reference","title":"InterpolationKernels.BSpline","text":"BSpline{S,T}()\n\nyields a B-spline (short for basis spline) of order S for floating-point T.  A B-spline of order S is a piecewise polynomial function of degree S - 1 on a support of length S.\n\nNot all B-spline are implemented in InterpolationKernels:, S must be: 1 (for a rectangular B-spline), 2 (for a linear B-spline), 3 (for a quadratic B-spline), or 4 (for a cubic B-spline).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.BSplinePrime","page":"Reference","title":"InterpolationKernels.BSplinePrime","text":"BSplinePrime{S,T}()\n\nyields the derivative of a B-spline of order S for floating-point T.\n\nSee InterpolationKernels.BSpline.\n\n\n\n\n\n","category":"type"},{"location":"library/#Generic-cubic-spline-1","page":"Reference","title":"Generic cubic spline","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"CubicSpline\nCubicSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.CubicSpline","page":"Reference","title":"InterpolationKernels.CubicSpline","text":"CubicSpline{T}(a, b) -> ker\n\nyields an instance of a generic cubic spline for floating-point type T and parameters a = ker'(1) and b = ker(1) the slope and the value of the function ker(x) at x = 1.\n\nA cubic spline kernel is at least C¹ continuous, the expression ker' yields a kernel instance implementing the 1st derivative of the generic cubic spline ker (see CubicSplinePrime to directly build a derivative).\n\nDepending on the values of the parameters a and b, more specific cubic spline kernels can be emulated:\n\nCubicSpline{T}(-1/2,1/6) yields a cubic B-spline as built by BSpline{4,T}().\nCubicSpline{T}(a,0) yields a cardinal cubic spline as built by CardinalCubicSpline{T}(a).\nCubicSpline{T}(-1/2,0) yields a Catmull-Rom kernel as built by CatmullRomSpline{T}().\nCubicSpline{T}(-b/2-c,b/6) yields Mitchell & Netravali cubic spline as built by MitchellNetravaliSpline{T}(b,c).\n\nInstances of CubicSpline are very well optimized and, in practice, they may be as fast or even faster than these more specialized counterparts.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.CubicSplinePrime","page":"Reference","title":"InterpolationKernels.CubicSplinePrime","text":"CubicSplinePrime{T}(a, b)\n\nyields a kernel instance that is the 1st derivative of the generic cubic spline of parameters a and b (see CubicSpline) for floating-point type T (Float64 by default).\n\n\n\n\n\n","category":"type"},{"location":"library/#Cardinal-cubic-splines-1","page":"Reference","title":"Cardinal cubic splines","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"CardinalCubicSpline\nCardinalCubicSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.CardinalCubicSpline","page":"Reference","title":"InterpolationKernels.CardinalCubicSpline","text":"CardinalCubicSpline{T}(a)\n\nyields an instance of the Keys family of cardinal cubic splines for floating-point type T and parameter a = ker'(1) the slope of the function ker(x) at x = 1.\n\nThese kernels are C¹ continuous piecewise normalized cardinal cubic spline which depend on one parameter a and defined by:\n\nker(x) = 1 + ((2 + a)*|x| - (3 + a))*x^2    if |x| ≤ 1\n         a*(|x| - 1)*(|x| - 2)^2            if 1 ≤ |x| ≤ 2\n         0                                  if |x| ≥ 2\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the Keys kernel ker (also see the constructor CardinalCubicSplinePrime).\n\nReference:\n\nKeys, Robert, G., \"Cubic Convolution Interpolation for Digital Image Processing\", IEEE Trans. Acoustics, Speech, and Signal Processing, Vol. ASSP-29, No. 6, December 1981, pp. 1153-1160.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.CardinalCubicSplinePrime","page":"Reference","title":"InterpolationKernels.CardinalCubicSplinePrime","text":"CardinalCubicSplinePrime{T}(a)\n\nyields a kernel instance that is the 1st derivative of the Keys cardinal cubic spline (see CardinalCubicSpline) for floating-point type T and parameter a.  This derivative is given by:\n\nker′(x) = (3(a + 2)*|x| - 2(a + 3))*x           if |x| ≤ 1\n          (3a)*(|x| - 2)*(|x| - 4/3)*sign(x)    if 1 ≤ |x| ≤ 2\n          0                                     if |x| ≥ 2\n\n\n\n\n\n","category":"type"},{"location":"library/#Catmull-Rom-interpolation-kernel-1","page":"Reference","title":"Catmull-Rom interpolation kernel","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"CatmullRomSpline\nCatmullRomSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.CatmullRomSpline","page":"Reference","title":"InterpolationKernels.CatmullRomSpline","text":"CatmullRomSpline{T}()\n\nyields an instance of the Catmull-Rom interpolation kernel for floating-point type T which is assumed to be Float64 if omitted.\n\nCatmull-Rom interpolation kernel is a cardinal piecewise cubic spline defined by:\n\nker(x) = ((3/2)*|x| - (5/2))*x^2 + 1             if |x| ≤ 1\n         (((5/2) - (1/2)*|x|)*|x| - 4)*|x| + 2   if 1 ≤ |x| ≤ 2\n         0                                       if |x| ≥ 2\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the Catmull-Rom interpolation kernel ker (also see the constructor CatmullRomSplinePrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.CatmullRomSplinePrime","page":"Reference","title":"InterpolationKernels.CatmullRomSplinePrime","text":"CatmullRomSplinePrime{T}()\n\nyields a kernel instance that is the 1st derivative of the Catmull-Rom interpolation kernel (see CatmullRomSpline) for floating-point type T which is assumed to be Float64 if omitted.\n\nThe 1st derivative of the Catmull-Rom interpolation kernel is given by:\n\nker′(x) = ((9/2)*|x| - 5)*x                      if a = |x| ≤ 1\n          (5 - (3/2)*|x|)*x - 4*sign(x)          if 1 ≤ |x| ≤ 2\n          0                                      if |x| ≥ 2\n\n\n\n\n\n","category":"type"},{"location":"library/#Mitchell-Netravali-kernels-1","page":"Reference","title":"Mitchell-Netravali kernels","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"MitchellNetravaliSpline\nMitchellNetravaliSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.MitchellNetravaliSpline","page":"Reference","title":"InterpolationKernels.MitchellNetravaliSpline","text":"MitchellNetravaliSpline{T}(b=1/3, c=1/3)\n\nyields an instance of the Mitchell & Netravali family of kernels for floating-point type T and parameters (b,c).\n\nThese kernels are cubic splines which depends on 2 parameters, b and c. Whatever the values of (b,c), Mitchell & Netravali kernels are normalized, even and C¹ continuous functions (these kernels and their first derivatives are continuous).\n\nTaking b = 0 yields the family of cardinal cubic splines (see CardinalCubicSpline) and is a sufficient and necessary condition to have Mitchell & Netravali kernels be cardinal functions.\n\nUsing the constraint: b + 2c = 1 yields a cubic filter with, at least, quadratic order approximation.\n\nSome specific values of (b,c) yield other well known kernels:\n\n(b,c) = (1,0)      --> cubic B-spline\n(b,c) = (0,-a)     --> Keys's cardinal cubic spline CardinalCubicSpline(a)\n(b,c) = (0,1/2)    --> Catmull-Rom kernel CatmullRomSpline()\n(b,c) = (b,0)      --> Duff's tensioned B-spline\n(b,c) = (6β,-α-3β) --> generic cubic spline CubicSpline(α,β)\n(b,c) = (1/3,1/3)  --> recommended by Mitchell-Netravali\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the Mitchell & Netravali kernel ker (also see the constructor MitchellNetravaliSplinePrime).\n\nReference:\n\nMitchell & Netravali, \"Reconstruction Filters in Computer Graphics\", in Computer Graphics, Vol. 22, Num. 4 (1988). http://www.cs.utexas.edu/users/fussell/courses/cs384g/lectures/mitchell/Mitchell.pdf.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.MitchellNetravaliSplinePrime","page":"Reference","title":"InterpolationKernels.MitchellNetravaliSplinePrime","text":"MitchellNetravaliSplinePrime([T=Float64,] [b=1/3, c=1/3,] B=Flat)\n\nyields a kernel instance that is the 1st derivative of the Mitchell & Netravali kernel (see MitchellNetravaliSpline) for floating-point type T, parameters b and c and boundary conditions B.\n\n\n\n\n\n","category":"type"},{"location":"library/#Lanczos-re-sampling-kernels-1","page":"Reference","title":"Lanczos re-sampling kernels","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"LanczosKernel\nLanczosKernelPrime","category":"page"},{"location":"library/#InterpolationKernels.LanczosKernel","page":"Reference","title":"InterpolationKernels.LanczosKernel","text":"LanczosKernel{S,T}()\n\nyields an instance of a Lanczos re-sampling kernel of support size S (which must be even) and for floating-point type T.\n\nThe Lanczos re-sampling kernels are even cardinal functions which tend to be normalized for large support size.  They are defined by:\n\nker(x) = S/(2*(π*x)^2)*sin(π*x)*sin(2*π*x/S)     if |x| ≤ S/2\n         0                                       if |x| ≥ S/2\n\nThe expression ker' yields the first derivative of a Lanczos re-sampling kernel ker (also see the constructor LanczosKernelPrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.LanczosKernelPrime","page":"Reference","title":"InterpolationKernels.LanczosKernelPrime","text":"LanczosKernelPrime{S,T}()\n\nyields a kernel instance that is the 1st derivative of the Lanczos re-sampling kernel (see LanczosKernel) of support size S and for floating-point type T.\n\n\n\n\n\n","category":"type"},{"location":"basics/#Basic-usage-1","page":"Basic usage","title":"Basic usage","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"An interpolation kernel Kernel{T,S} is parametrized by the floating-point type T of its coefficients and by the (integer) size S of its support.  For efficiency reasons, only kernels with (small) finite size supports are implemented.  To create a kernel instance, call its constructor; for example:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"ker = LanczosKernel{6}()","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"yields a Lanczos re-sampling kernel of size 6 (see Interpolation kernels for an exhaustive list of kernels implemented in InterpolationKernels) and using floating-point tytpe Float64 for computations.  The same kind of kernel with a specific floating-point type, say T, is created as:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"ker = LanczosKernel{6,T}()","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Any interpolation kernel ker is a callable object which may be used as a function with a real argument:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"ker(x::Real)","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"yields kernel value at x.  In InterpolationKernels, all kernel supports are symmetric; that is ker(x) is zero if abs(x) > S/2 with S the size of the kernel support.","category":"page"},{"location":"basics/#Basic-methods-1","page":"Basic usage","title":"Basic methods","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Some simple methods are available for any interpolation kernel ker:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"eltype(ker) yields the floating-point type T for calculations;\nlength(ker) yields the number S of samples in the support of ker which is also the number of neighbors involved in an interpolation by this kernel;","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Since the floating-point type T and the support size S are parameters of the interpolation kernel type, the above methods can also be applied to the type of an interpolation kernel.","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Some interpolation kernels have numerical parameters, these parameters can be retrieved by:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"values(ker)","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"which yields a tuple of parameters, possibly empty.  A kernel instance identical to ker can be built as follows:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"typeof(ker)(values(ker)...)","category":"page"},{"location":"basics/#Kernel-floating-point-type-1","page":"Basic usage","title":"Kernel floating-point type","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Calling a kernel ker with a real argument x, as ker(x), always yield a floating-point of type T = eltype(ker).  This property has been imposed for efficiency reasons when interpolating arrays.  Calling a kernel ker with an argument x that has a different floating-point type is therefore less efficient as it involves converting the value of the real x.  It is however very easy to change the floating-point type used by a kernel.","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"A kernel object ker can be converted to use a given floating-point type. For example, assuming ker is a kernel instance, one can do either of:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"convert(Kernel{Float32}, ker)\nKernel{Float32}(ker)\nFloat32(ker)","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"to use Float32 floating-point arithmetic with ker.","category":"page"},{"location":"basics/#Traits-1","page":"Basic usage","title":"Traits","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Methods iscardinal and isnormalized can be used to query whether a kernel is a cardinal function (that is a function which yields zero for all non-zero integers) and whether a kernel has the partition of unity property.  For some parametric kernels, these traits depend on the specific values of the parameters so these methods take a kernel instance (not a type) as argument.","category":"page"},{"location":"basics/#Derivative-1","page":"Basic usage","title":"Derivative","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"The expression ker' yields a kernel instance which is the 1st derivative of the kernel ker.  Having the derivative of a kernel is useful in a number of practical cases.  For instance, thanks to linearity of the interpolation procedure, interpolating an array A with the derivative ker' is equivalent to taking the 1st derivative of the continuous function modeled by interpolating the array A with the kernel ker.","category":"page"},{"location":"basics/#Interpolation-weights-1","page":"Basic usage","title":"Interpolation weights","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Efficient computation of interpolation weights is implemented by the InterpolationKernels.compute_offset_and_weights InterpolationKernels.compute_weights methods.  These methods are not exported because they are only required to implement array interpolation, as done by the FineShift or LinearInterpolators packages. The principles of interpolation are detailed in another section.","category":"page"},{"location":"install/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"InterpolationKernels is not yet an offical Julia package but its installation can be as easy as:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> add https://github.com/emmt/InterpolationKernels.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"where … pkg> represents the package manager prompt (the ellipsis … denote your current environment).  To start Julia's package manager, launch Julia and, at the REPL of Julia, hit the ] key; you should get the above … pkg> prompt.  To revert to Julia's REPL, just hit the Backspace key at the … pkg> prompt.","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"More detailed explanations are given below.","category":"page"},{"location":"install/#Using-the-package-manager-1","page":"Installation","title":"Using the package manager","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"InterpolationKernels can be installed by Julia's package manager using https protocol:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> add https://github.com/emmt/InterpolationKernels.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"or ssh protocol:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> add git@github.com:emmt/InterpolationKernels.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"To check whether the InterpolationKernels package works correctly, type:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> test InterpolationKernels","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"Later, to update to the last version (and run tests), you can type:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> update InterpolationKernels\n… pkg> test InterpolationKernels","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"If something goes wrong, it may be because you already have an old version of InterpolationKernels.  Uninstall InterpolationKernels as follows:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> rm InterpolationKernels\n… pkg> gc\n… pkg> add https://github.com/emmt/InterpolationKernels.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"before re-installing.","category":"page"},{"location":"install/#Installation-in-scripts-1","page":"Installation","title":"Installation in scripts","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"To install InterpolationKernels in a Julia script, write:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/emmt/InterpolationKernels.jl\",\n                    rev=\"master\"));","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"or with url=\"git@github.com:emmt/InterpolationKernels.jl\" if you want to use ssh.","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"This also works from the Julia REPL.","category":"page"},{"location":"interpolation/#Interpolation-1","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Interpolation kernels, as their name suggest, are designed for interpolating arrays.  The InterpolationKernels package provides the InterpolationKernels.compute_weights method to efficiently compute interpolation weights for a given kernel and offset.","category":"page"},{"location":"interpolation/#Interpolation-principles-1","page":"Interpolation","title":"Interpolation principles","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"To explain how linear interpolation works, let us assume that we want to interpolate a source vector src using the kernel ker: ℝ → ℝ to produce a continuous model function mdl(x) with x ∈ ℝ the continuous coordinate. Such a model writes:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"mdl(x) = sum_{j ∈ J} ker(x - j)*src[j]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where sum_{j ∈ J} denotes a sum over all indices j of src, that is J = axes(src,1).  The above equation is a convolution of the source src by the kernel ker.  The model function is mdl: ℝ → 𝕂 where 𝕂 is the type of the product in the above sum.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"If the kernel ker has a finite support of size S ∈ ℕ, there are at most S nonzero ker(…) terms in the sum.  Moreover, if S is much smaller than the length of src and to spare computations, it is worth rewriting the result of the interpolation as:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"mdl(x) = sum_{k ∈ 1:S} ker(x + p - k)*src[k - p]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"for some well chosen p ∈ ℤ so that the sum over k accounts for all nonzero ker(…) terms.  This means that if [kmin,kmax] is the support of ker(x) (with kmax = kmin + S), then the following inequalities must hold:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"kmin ≤ x + p - maximum(1:S) ≤ x + p - minimum(1:S) ≤ kmax","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where minimum(1:S) ≡ 1 and maximum(1:S) ≡ S are the minimum and the maximum indices k in the sum sum_{k ∈ 1:S}.  Re-arranging terms yields that pmin ≤ p ≤ pmax must hold with:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"pmin = kmin - x + S\npmax = kmax - x + 1","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Note that the width of the interval [pmin,pmax] is pmax - pmin = 1 since kmax = kmin + S, so the interval [pmin,pmax] always contains at least one integer and contains at most two integers when pmin (and pmax) is integer. This leaves 2 possibilities for choosing p ∈ [pmin,pmax] ∩ ℤ:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"p = ceil(pmax) - 1 =  ceil(kmax - x)\np = floor(pmax)    = floor(kmax - x + 1)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"which are equivalent for most but not all values of x (they differ when kmax-x happens to be integer).  If ker(kmin) = ker(kmax) = 0, which should be the case if ker(x) is everywhere continuous, the choice between these two possibilities is irrelevant for the result of the interpolation.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Now introducing the so-called interpolation weights given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"w[k] = ker(x + p - k)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"for k ∈ 1:S, the interpolation can be rewritten as","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"dst[i] = sum_{k ∈ 1:S} w[k]*src[k - p]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"which is a correlation of w and src.","category":"page"},{"location":"interpolation/#Interpolation-weights-1","page":"Interpolation","title":"Interpolation weights","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"In InterpolationKernels all kernels have a symmetric support, hence kmin = -kmax and kmax = S/2.  The interpolation weights are then given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"w[k] = ker(x + ceil(S/2 - x) - k)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"for k ∈ 1:S and assuming that p = ceil(kmax - x) has been chosen among the two possibilities.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Instead of computing the nonzero interpolation weights one by one by S calls to the kernel function, it may be beneficial to compute all weights in a row exploiting common sub-expressions.  This facility is provided by the kernels in InterpolationKernels and the interpolation weights for kernel ker can be computed by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"w = InterpolationKernels.compute_weights(ker, t)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"which yields an S-tuple w of weights with S the size of the support of the kernel ker.  To interpolate around position x (in fractional index units), the offset t is given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"if S is even:\nt = x - floor(x)\nif S is odd:\nt = x - floor(x + 1/2) = x - round(x)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"The offset t is therefore in the range [0,1] for S even and in the range [-1/2,+1/2] for S odd.  The bounds being inclusive or not is irrelevant for the result (so the rounding direction does not matter).","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"One of the reasons of using these conventions is that the integer index:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"j = (iseven(S) ? floor(Int, x) : round(Int, x))","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"such that t = x - j plays a central role in determining the indices of the entries in the interpolated array involved in the interpolation formula.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"For developers who would like to implement other kernels than those provided by InterpolationKernels, it is necessary to derive the general formula for the weights as functions of the offset t.  Recalling that w[k] = ker(v - k) with v = x + ceil(S/2 - x), the identity ceil(-u) = -floor(u) for any real u can be used to rewrite v as:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"v = x + ceil(S/2 - x)\n  = x - floor(x - S/2)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"now 2 different cases must be considered depending on the parity of S:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"if S is even, then S = 2c with c integer, therefore S/2 = c and:\nv = x - floor(x - c) = x - floor(x) + c = t + c\nif S is odd, then S = 2c - 1 with c integer, therefore S/2 = c - 1/2 and:\nv = x - floor(x - c + 1/2) = x - floor(x + 1/2) + c = t + c","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"To summarize, the interpolations weights are simply given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"w[k] = ker(t + c - k)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"c = (S + 1) ÷ 2","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with ÷ the integer division in Julia.","category":"page"},{"location":"interpolation/#Example:-fine-shifting-1","page":"Interpolation","title":"Example: fine shifting","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Let us now assume that we want to compute:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"dst[i] ≈ src[i - r]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"for all indices i ∈ I of the destination vector dst and some non-integer offset r where ≈ denotes the approximation by the interpolation model mdl(x) described above.  Hence dst is the result of performing a sub-sample shift of src by offset r.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Combining equations (that is just replace x by i-r) yields:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"dst[i] = mdl(i - r)\n       = sum_{j ∈ J} ker(i - r - j)*src[j]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"In order to spare computations, we take j = i - q + k for some well chosen integer q and rewrite the interpolation as:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"dst[i] = sum_{k ∈ 1:R} ker(q - r - k)*src[i - q + k]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"we have to chose q such that the following inequalities hold:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"kmin ≤ q - r - S ≤ q - r - 1 ≤ kmax","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with [kmin,kmax] the support of the kernel ker and kmax - kmin = S as before.  These inequalities are equivalent to:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"(qmin = kmin + r + S) ≤ q ≤ (qmax = kmax + r + 1)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"as before qmax - qmin = 1 and there are 2 possibilities for choosing q:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"q = ceil(qmax) - 1 = ceil(kmax + r)\nq = floor(qmax) = floor(kmax + 1 + r)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Taking the second choice for q and assuming a symmetric support (hence kmax = S/2) yields:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"q = floor(S/2 + 1 + r)\n  = floor(c + r)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where c = 1 + S/2.  The interpolation weights are now given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"w[k] = ker(v - k)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"v = q - r\n  = floor(S/2 + 1 + r) - r","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Finally the result of fine shifting writes:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"dst[i] = sum_{k ∈ 1:R} w[k]*src[i - q + k]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where the weights w and offset q do not depend on i and can thus be pre-computed resulting in very fast computations.  This is exploited by the FineShift package.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"If flat boundary conditions hold, we are assuming that src[j] = src[1] if j ≤ 1 and src[j] = src[n] if j ≥ n with n = length(src) the number of samples in src.  Then, if the shift r is too large (in magnitude) all j = i + k - q for k = 1, ..., S are below or above the limits in the interpolation formula.  This occurs when:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"i + k - q ≤ 1  (∀ i,k)  <=> i + S - 1 ≤ q  (∀ i)  <=> S + m - 1 ≤ q\ni + k - q ≥ n  (∀ i,k)  <=>         i ≥ q  (∀ i)  <=> 1 ≥ q","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The InterpolationKernels package provides a library of interpolation kernels for Julia.  As suggested by their name, interpolations kernels are mostly designed for interpolation, they can be thought as smart functions that know their derivative and that implement optimized computation of interpolation weights.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The source code is on GitHub.","category":"page"},{"location":"#Table-of-contents-1","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"install.md\", \"basics.md\", \"kernels.md\",\n         \"interpolation.md\", \"library.md\"]","category":"page"},{"location":"#Index-1","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
