var documenterSearchIndex = {"docs":
[{"location":"kernels/#Kernels-1","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"InterpolationKernels provide the following kernels (T is an optional floating-point type):","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Types Support Cardinal Parameters Description\nBSpline{1,T} 1 yes  rectangular B-spline\nBSpline{2,T} 2 yes  linear B-spline\nBSpline{3,T} 3 no  quadratic B-spline\nBSpline{4,T} 4 no  cubic B-spline\nCubicSpline{T} 4 yes/no a, b cubic splines\nCardinalCubicSpline{T} 4 yes a cardinal cubic splines\nCatmullRomSpline{T} 4 yes  Catmull & Rom kernel\nMitchellNetravaliSpline{T} 4 yes/no b, c Mitchell & Netravali kernels\nLanczosKernel{S,T} S yes S Lanczos re-sampling kernels","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"In this table, the Cardinal column indicates whether a kernel ker(x) is a cardinal function, that is ker(k) = 0 for all integers k except that ker(0) = 1 which makes such a kernel directly suitable for interpolation.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"A spline is defined as a piecewise polynomial of given degree.  A B-spline of order S is a piecesiwe polynomial of degree S - 1 which is everywhere nonnegative, an even and normalized function (its integral is equal to 1).","category":"page"},{"location":"kernels/#Rectangular-interpolation-kernel-1","page":"Kernels","title":"Rectangular interpolation kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The rectangular interpolation kernel (also known as box kernel or Fourier window or Dirichlet window) is the 1st order B-spline equals to 1 on [-1/2,+1/2), and 0 elsewhere.  Interpolation by a rectangular spline amounts to interpolating by the nearest neighbor.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"An instance of a rectangular interpolation kernel is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = BSpline{1,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of the kernel ker.  An instance of a kernel implementing the first derivative of a rectangular interpolation kernel may be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":" BSplinePrime{1,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where, again, the floating-point type parameter T my be omitted.","category":"page"},{"location":"kernels/#Triangular-interpolation-kernel-1","page":"Kernels","title":"Triangular interpolation kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The triangular interpolation kernel linear spline (also known as triangle kernel or Bartlett window or Fejér window) is the 2nd order B-spline defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = 1 - |x|       if |x| ≤ 1\n         0             if |x| ≥ 1","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"An instance of a triangular interpolation kernel is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = BSpline{2,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of the kernel ker.  An instance of a kernel implementing the first derivative of a triangular interpolation kernel may be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":" BSplinePrime{2,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where, again, the floating-point type parameter T my be omitted.","category":"page"},{"location":"kernels/#Quadratic-B-spline-1","page":"Kernels","title":"Quadratic B-spline","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The quadratic B-spline is the 3rd order B-spline defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = 3/4 - x^2                   if |x| ≤ 1/2\n         (1/2)*(|x| - 3/2)^2         if |x| ≤ 3/2\n         0                           if |x| ≥ 3/2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"An instance of a quadratic B-spline is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"BSpline{3,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of the kernel ker.  An instance of a kernel implementing the first derivative of a quadratic B-spline may be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":" BSplinePrime{3,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where, again, the floating-point type parameter T my be omitted.","category":"page"},{"location":"kernels/#Cubic-B-spline-1","page":"Kernels","title":"Cubic B-spline","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The 4th order (cubic) B-spline kernel (also known as Parzen window or as de la Vallée Poussin window) is defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = (|x|/2 - 1)*|x|^2 + 2/3     if |x| ≤ 1\n         (1/6)*(2 - |x|)^3           if 1 ≤ |x| ≤ 2\n         0                           if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"An of a cubic B-spline is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"BSpline{4,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The cubic B-spline is a C² continuous function (its derivatives up to the second one are everywhere continuous).  The expression ker' yields the first derivative of the kernel ker.  An instance of a kernel implementing the first derivative of a cubic B-spline may be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":" BSplinePrime{4,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where, again, the floating-point type parameter T my be omitted.","category":"page"},{"location":"kernels/#Cubic-splines-1","page":"Kernels","title":"Cubic splines","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"An instance of the familily of cubic spline kernels is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = CubicSpline{T}(a, b)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"and is defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = ((2 + a - 6b)*|x| +  (9b - a - 3))*x^2 + (1 - 2b)  if |x| ≤ 1\n         ((a + 2b)*|x| - (a + b))*(|x| - 2)^2               if |x| ≤ 2\n         0                                                  if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The parameters a = ker'(1) and b = ker(1) are the slope and the value of the function ker(x) at x = 1.  The type parameter T is the floating-point type for computations T, it may be omitted in which case it is guessed from the types of a and b as T = float(promote(typeof(a), typeof(b))).","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"A cubic spline kernel is at least C¹ continuous, the expression ker' yields a kernel instance implementing the 1st derivative of the generic cubic spline ker.  Such a derivative may be directly built by calling:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"CubicSplinePrime{T}(a, b)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Depending on the values of the parameters a and b, more specific cubic spline kernels can be emulated:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"CubicSpline{T}(-1/2,1/6) yields a cubic B-spline as built by BSpline{4,T}().\nCubicSpline{T}(a,0) yields a cardinal cubic spline as built by CardinalCubicSpline{T}(a).\nCubicSpline{T}(-1/2,0) yields a Catmull-Rom kernel as built by CatmullRomSpline{T}().\nCubicSpline{T}(-b/2-c,b/6) yields Mitchell & Netravali cubic spline as built by MitchellNetravaliSpline{T}(b,c).","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Calling BSpline, CatmullRomSpline, CardinalCubicSpline, or MitchellNetravaliSpline to build these more specialized cubic splines may yield more efficient kernels as computations involve more simple expressions.  Instances of CubicSpline are however very well optimized and, in practice, they may be as fast or even faster than their more specialized counterparts.  If ultimate performances matter, the BenchmarkTools package may helps you to decide which kernel to choose for a given machine.","category":"page"},{"location":"kernels/#Cardinal-cubic-splines-1","page":"Kernels","title":"Cardinal cubic splines","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Keys kernels form the family of cardinal cubic splines.  A cardinal cubic spline is defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = 1 - (a + 3)*x^2 + (a + 2)*|x|^3      if |x| ≤ 1\n         -4a + 8a*|x| - 5a*x^2 + a*|x|^3      if 1 ≤ |x| ≤ 2\n         0                                    if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"These kernels are C¹ continuous piecewise normalized cardinal cubic spline which depend on one parameter a = ker'(1) the slope of the function ker(x) at x = 1.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a cardinal cubic spline with parameter a, call:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = CardinalCubicSpline{T}(a)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where T is the floating-point type for computations.  If omitted, T is typeof(a) if it is Float16, Float32, Float64, or BigFloat and Float64 otherwise.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of the cardinal cubic spline ker.  An instance of the first derivative of such a kernel can also be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"CardinalCubicSplinePrime{T}(a)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"with the same default for T if this parameter is omitted.","category":"page"},{"location":"kernels/#References-1","page":"Kernels","title":"References","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Keys, Robert, G., \"Cubic Convolution Interpolation for Digital Image Processing\", IEEE Trans. Acoustics, Speech, and Signal Processing, Vol. ASSP-29, No. 6, December 1981, pp. 1153-1160.","category":"page"},{"location":"kernels/#Catmull-and-Rom-kernel-1","page":"Kernels","title":"Catmull & Rom kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The Catmull-Rom kernel is a cardinal piecewise cubic spline defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = ((3/2)*|x| - (5/2))*x^2 + 1             if |x| ≤ 1\n         (((5/2) - (1/2)*|x|)*|x| - 4)*|x| + 2   if 1 ≤ |x| ≤ 2\n         0                                       if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Being a cardinal function, the Catmull-Rom kernel is suitable for interpolation.  Its derivative is given by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker′(x) = ((9/2)*|x| - 5)*x                      if a = |x| ≤ 1\n          (5 - (3/2)*|x|)*x - 4*sign(x)          if 1 ≤ |x| ≤ 2\n          0                                      if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a Catmull-Rom interpolation kernel, call","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = CatmullRomSpline{T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.  To create an instance of the derivative of a Catmull-Rom interpolation kernel, call one of:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"kerp = ker'\nkerp = CatmullRomSplinePrime{T}()","category":"page"},{"location":"kernels/#Mitchell-and-Netravali-kernels-1","page":"Kernels","title":"Mitchell & Netravali kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Mitchell & Netravali kernels are a specific form of the family of cubic splines.  These kernels are parametric piecewise cubic splines defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = (1/6)*(((12 - 9b - 6c)*|x| - 18 + 12b + 6c)*x^2 + (6 - 2b))   if |x| ≤ 1\n         (1/6)*(2b + 6c - (b + 6c)*|x|)*(2 - |x|)^2                    if 1 ≤ |x| ≤ 2\n         0                                                             if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Instances of a Mitchell & Netravali kernel and of its derivative are respectively created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"MitchellNetravaliSpline{T}(b, c)\nMitchellNetravaliSplinePrime{T}(b, c)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"with T the floating-point type for computations.  If T is omitted but b and c are specified, T is deduced from the floating-point type of b and c.  If b and c are omitted, (b,c) = (1/3,1/3) is assumed as recommended by Mitchell & Netravali.  If T is omitted and b and c are omitted or both integers, T = Float64 is assumed.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Whatever the values of the parameters b and c, Mitchell & Netravali kernels are normalized and even functions of class C¹ (these kernels and their first derivatives are continuous).  The expression ker' yields the first derivative of a Mitchell & Netravali kernel ker.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Taking b = 0 yields Keys's family of kernels and is a sufficient and necessary condition to have Mitchell & Netravali kernels be cardinal functions.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Using the constraint: b + 2c = 1 yields a cubic filter with, at least, quadratic order approximation.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Some specific values of (b,c) yield other well known kernels:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"(b,c) = (1,0)      --> cubic B-spline\n(b,c) = (0,-a)     --> Keys's cardinal cubic spline CardinalCubicSpline(a)\n(b,c) = (0,1/2)    --> Catmull-Rom kernel CatmullRomSpline()\n(b,c) = (b,0)      --> Duff's tensioned B-spline\n(b,c) = (6β,-α-3β) --> generic cubic spline CubicSpline(α,β)\n(b,c) = (1/3,1/3)  --> recommended by Mitchell-Netravali","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"This family of kernels and their derivatives is implemented as instances of CubicSpline and CubicSplinePrime using the following property:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"MitchellNetravaliSpline{T}(b, c) = CubicSpline{T}(-b/2 - c, b/6)","category":"page"},{"location":"kernels/#References-2","page":"Kernels","title":"References","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Mitchell & Netravali, \"Reconstruction Filters in Computer Graphics\", in Computer Graphics, Vol. 22, Num. 4 (1988) pdf.","category":"page"},{"location":"kernels/#Lanczos-re-sampling-kernels-1","page":"Kernels","title":"Lanczos re-sampling kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The Lanczos re-sampling kernels are defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = (S/2π²)*sin(π*x)*sin(2π*x/S)/x^2   if |x| ≤ S/2\n         0                                  if |x| ≥ S/2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The Lanczos re-sampling kernels are even cardinal functions which tend to be normalized for large support size (see this Wikipedia page).","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a Lanczos re-sampling kernel of support size S (which must be even), call:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"LanczosKernel{S,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where the floating-point type T is assumed to be Float64 if omitted.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of a Lanczos re-sampling kernel ker.  An instance of a kernel implementing the first derivative of a Lanczos re-sampling kernel can also be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"LanczosKernelPrime{S,T}()","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where, again, it is possible to omit the floating-point type parameter T.","category":"page"},{"location":"library/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"The following provides detailled documentation about types and methods provided by the InterpolationKernels package.  This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"library/#Kernel-supports-1","page":"Reference","title":"Kernel supports","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"InterpolationKernels.Support\nInterpolationKernels.SymmetricSupport\nInterpolationKernels.LeftAnchoredSupport\nInterpolationKernels.RightAnchoredSupport\nInterpolationKernels.infimum\nInterpolationKernels.supremum","category":"page"},{"location":"library/#InterpolationKernels.Support","page":"Reference","title":"InterpolationKernels.Support","text":"InterpolationKernels.Support{T,S,L,R} is the abstract type for the support of an interpolation kernel parameterized by the floating-point type T used for computations, the integer size S of the support and the types L and R of the left and right bound which can be InterpolationKernels.Open or InterpolationKernels.Closed.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.SymmetricSupport","page":"Reference","title":"InterpolationKernels.SymmetricSupport","text":"InterpolationKernels.SymmetricSupport{T,S,L,R}() -> sup\n\nyields an instance of a symmetric support parameterized by the floating-point type T, the integer size S of the support and the types L and R of the left and right bound which can be InterpolationKernels.Open or InterpolationKernels.Closed.\n\nDepending on L and R, the support is:\n\n(L,R) = (Open,Open) -------> sup = (-S/2,S/2)\n(L,R) = (Closed,Open) -----> sup = [-S/2,S/2)\n(L,R) = (Open,Closed) -----> sup = (-S/2,S/2]\n(L,R) = (Closed,Closed) ---> sup = [-S/2,S/2]\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.LeftAnchoredSupport","page":"Reference","title":"InterpolationKernels.LeftAnchoredSupport","text":"InterpolationKernels.LeftAnchoredSupport{T,S,L,R}(a)\n\nyields an instance of a support with lower bound a and parameterized by the floating-point type T, the integer size S of the support and the types L and R of the left and right bound which can be InterpolationKernels.Open or InterpolationKernels.Closed.\n\nDepending on L and R, the support is:\n\n(L,R) = (Open,Open) -------> sup = (a,a+S)\n(L,R) = (Closed,Open) -----> sup = [a,a+S)\n(L,R) = (Open,Closed) -----> sup = (a,a+S]\n(L,R) = (Closed,Closed) ---> sup = [a,a+S]\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.RightAnchoredSupport","page":"Reference","title":"InterpolationKernels.RightAnchoredSupport","text":"InterpolationKernels.RightAnchoredSupport{T,S,L,R}(b)\n\nyields an instance of a support with upper bound b and parameterized by the floating-point type T, the integer size S of the support and the types L and R of the left and right bound which can be InterpolationKernels.Open or InterpolationKernels.Closed.\n\nDepending on L and R, the support is:\n\n(L,R) = (Open,Open) -------> sup = (b-S,b)\n(L,R) = (Closed,Open) -----> sup = [b-S,b)\n(L,R) = (Open,Closed) -----> sup = (b-S,b]\n(L,R) = (Closed,Closed) ---> sup = [b-S,b]\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.infimum","page":"Reference","title":"InterpolationKernels.infimum","text":"InterpolationKernels.infimum(sup) -> a\n\nyields the greatest lower bound a of the kernel support sup.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.supremum","page":"Reference","title":"InterpolationKernels.supremum","text":"InterpolationKernels.supremum(sup) -> b\n\nyields the least upper bound b of the kernel support sup.\n\n\n\n\n\n","category":"function"},{"location":"library/#Interpolation-kernels-1","page":"Reference","title":"Interpolation kernels","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"Kernel\nInterpolationKernels.iscardinal\nInterpolationKernels.isnormalized\nInterpolationKernels.support\nInterpolationKernels.brief\nInterpolationKernels.compute_weights\nInterpolationKernels.compute_offset_and_weights","category":"page"},{"location":"library/#InterpolationKernels.Kernel","page":"Reference","title":"InterpolationKernels.Kernel","text":"Interpolation Kernels\n\nAn interpolation kernel Kernel{T,S} is parametrized by the floating-point type T of its coefficients and by the integer size S of its support.  For efficiency reasons, only kernels with (small) finite size supports are implemented.\n\nA kernel ker is a callable object which may be used as a function with a real argument:\n\nker(x::Real)\n\nyields kernel value at offset x.  Whatever the type of x, ker(x) is always of type T = eltype(ker) the floating-point type associated with ker. All kernel supports are symmetric; that is ker(x) is zero if abs(x) > S/2 with S = length(ker) the size of the kernel support.\n\nKernel floating-point type conversion\n\nCalled as a function with a real argument, a given kernel returns a value of its associated floating-point type.  This has been chosen to have fast interpolation methods.  Converting a kernel ker to use floating-point type T is simply done by one of:\n\nT(ker)\nKernel{T}(ker)\nconvert(Kernel{T}, ker)\n\nBeware that changing the floating-point type may lead to a loss of precision if the kernel has numerical parameters.\n\nCommon methods\n\nA few common methods are specialized for any interpolation kernel ker:\n\neltype(ker) -> T\n\nyields the floating-point type for calculations,\n\nlength(ker) -> S\n\nyield the size the support of ker which is also the number of neighbors involved in an interpolation by this kernel,\n\nvalues(ker)\n\nyields a tuple of the parameters of ker such that an identical instance can be built by:\n\ntypeof(ker)(values(ker)...)\n\nfinally:\n\ncompute_offset_and_weights(ker, x) -> off, (w1, w2, ..., wS)\n\nyields the offset off and an S-tuple of interpolation weights to interpolate an array at coordinate x (in fractional index units).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.iscardinal","page":"Reference","title":"InterpolationKernels.iscardinal","text":"iscardinal(ker)\n\nyields whether the kernel ker is zero for non-zero integer arguments. Cardinal kernels are directly suitable for interpolation.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.isnormalized","page":"Reference","title":"InterpolationKernels.isnormalized","text":"isnormalized(ker)\n\nyields whether the kernel ker has the partition of unity property.  That is, the sum of the values computed by the kernel ker on a unit spaced grid is equal to one.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.support","page":"Reference","title":"InterpolationKernels.support","text":"InterpolationKernels.support(ker) -> sup\n\nyields the support of the interpolation kernel ker.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.brief","page":"Reference","title":"InterpolationKernels.brief","text":"InterpolationKernels.brief(ker)\n\nyields a brief description of the kernel type or instance ker.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.compute_weights","page":"Reference","title":"InterpolationKernels.compute_weights","text":"InterpolationKernels.compute_weights(ker, t) -> wgt\n\ncomputes the interpolation weights returned by InterpolationKernels.compute_offset_and_weights for kernel ker with symmetric support.  Assuming interpolation is performed at at position x, argument t is given by:\n\n t = x - floor(x)     if length(ker) is even, hence t ∈ [0,1)\n t = x - round(x)     if length(ker) is odd,  hence t ∈ [-1/2,+1/2]\n\nThe returned weights are then:\n\n wgt = ntuple(i -> ker(t + k - i), length(ker))\n\nwhere k = (length(ker) + 1) >> 1 (i.e., integer division of length(ker)+1 by 2).  These conventions have been adopted so that, by specializing the compute_weights method, computing the length(ker) weights at the same time may be done in much fewer operations than calling ker as a function for each weight.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.compute_offset_and_weights","page":"Reference","title":"InterpolationKernels.compute_offset_and_weights","text":"InterpolationKernels.compute_offset_and_weights(ker, x) -> off, wgt\n\nyields the index offset off and the weights wgt to interpolate with kernel ker at position x in fractional index units.  The offset is a scalar and the weights are an n-tuple with n = length(ker) the size of the support of the kernel, all returned values have the same floating point type eltype(ker) as the kernel.\n\nNot taking into account boundary conditions, interpolating a vector A at position x would then write:\n\noff, wgt = InterpolationKernels.compute_offset_and_weights(ker, x)\nk = Int(off) # here boundary conditions should be imposed\nresult = wgt[1]*A[k+1] + ... + wgt[n]*A[k+n]\n\nNote that 1-based indexing is assumed by compute_offset_and_weights to interpret the position x and compute the offset off.  If this is not the case, the code should be:\n\nj1 = first(axes(A,1)) # first index in A\noff, wgt = InterpolationKernels.compute_offset_and_weights(ker, x - (j1 - 1))\nk = Int(off) + (j1 - 1) # here boundary conditions should be imposed\nresult = wgt[1]*A[k+1] + ... + wgt[n]*A[k+n]\n\nwhere expression x - (j1 - 1) is assuming that the position x is in fractional index for A, that is x = j1 at the first entry of A.\n\nnote: Note\nFor fast computations, this method should be specialized for specific kernel types.  For kernels with symmetric support, the method InterpolationKernels.compute_weights is called by compute_offset_and_weights to calculate the interpolation weights; for such kernels it is sufficient to specialize compute_weights instead of compute_offset_and_weights.\n\n\n\n\n\n","category":"function"},{"location":"library/#B-splines-1","page":"Reference","title":"B-splines","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"BSpline\nBSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.BSpline","page":"Reference","title":"InterpolationKernels.BSpline","text":"BSpline{S,T}()\n\nyields a B-spline (short for basis spline) of order S that is a piecewise polynomial function of degree S - 1 on a support of length S.  The parameter T is the floating-point type for computations, T = Float64 is assuled if this parameter is not specified.\n\nFr now, not all B-spline are implemented in InterpolationKernels, S must be: 1 (for a rectangular B-spline), 2 (for a linear B-spline), 3 (for a quadratic B-spline), or 4 (for a cubic B-spline).\n\nIf ker is a B-spline, then ker' is its derivative which can also be directly constructed by calling BSplinePrime.\n\nwarning: Warning\nThe derivative of B-spline of order S ≤ 2 is not defined everywhere.  It is allowed to take their derivative but it (arbitrarily) yields zero where not defined.  Returning NaN would have been more correct but it has been considered that it would do more harm than good in practice.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.BSplinePrime","page":"Reference","title":"InterpolationKernels.BSplinePrime","text":"BSplinePrime{S,T}()\n\nyields the derivative of a B-spline of order S for floating-point T.\n\nSee the caveats in BSpline about taking the derivative of B-splines of order S ≤ 2.\n\n\n\n\n\n","category":"type"},{"location":"library/#Generic-cubic-spline-1","page":"Reference","title":"Generic cubic spline","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"CubicSpline\nCubicSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.CubicSpline","page":"Reference","title":"InterpolationKernels.CubicSpline","text":"CubicSpline{T}(a, b) -> ker\n\nyields an instance of a generic cubic spline for floating-point type T and parameters a = ker'(1) and b = ker(1) the slope and the value of the function ker(x) at x = 1.\n\nA cubic spline kernel is at least C¹ continuous, the expression ker' yields a kernel instance implementing the 1st derivative of the generic cubic spline ker (see CubicSplinePrime to directly build a derivative).\n\nDepending on the values of the parameters a and b, more specific cubic spline kernels can be emulated:\n\nCubicSpline{T}(-1/2,1/6) yields a cubic B-spline as built by BSpline{4,T}().\nCubicSpline{T}(a,0) yields a cardinal cubic spline as built by CardinalCubicSpline{T}(a).\nCubicSpline{T}(-1/2,0) yields a Catmull-Rom kernel as built by CatmullRomSpline{T}().\nCubicSpline{T}(-b/2-c,b/6) yields Mitchell & Netravali cubic spline as built by MitchellNetravaliSpline{T}(b,c).\n\nInstances of CubicSpline are very well optimized and, in practice, they may be as fast or even faster than these more specialized counterparts.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.CubicSplinePrime","page":"Reference","title":"InterpolationKernels.CubicSplinePrime","text":"CubicSplinePrime{T}(a, b)\n\nyields a kernel instance that is the 1st derivative of the generic cubic spline of parameters a and b (see CubicSpline) for floating-point type T (Float64 by default).\n\n\n\n\n\n","category":"type"},{"location":"library/#Cardinal-cubic-splines-1","page":"Reference","title":"Cardinal cubic splines","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"CardinalCubicSpline\nCardinalCubicSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.CardinalCubicSpline","page":"Reference","title":"InterpolationKernels.CardinalCubicSpline","text":"CardinalCubicSpline{T}(a)\n\nyields an instance of the Keys family of cardinal cubic splines for floating-point type T and parameter a = ker'(1) the slope of the function ker(x) at x = 1.\n\nThese kernels are C¹ continuous piecewise normalized cardinal cubic spline which depend on one parameter a and defined by:\n\nker(x) = 1 + ((2 + a)*|x| - (3 + a))*x^2    if |x| ≤ 1\n         a*(|x| - 1)*(|x| - 2)^2            if 1 ≤ |x| ≤ 2\n         0                                  if |x| ≥ 2\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the Keys kernel ker (also see the constructor CardinalCubicSplinePrime).\n\nReference:\n\nKeys, Robert, G., \"Cubic Convolution Interpolation for Digital Image Processing\", IEEE Trans. Acoustics, Speech, and Signal Processing, Vol. ASSP-29, No. 6, December 1981, pp. 1153-1160.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.CardinalCubicSplinePrime","page":"Reference","title":"InterpolationKernels.CardinalCubicSplinePrime","text":"CardinalCubicSplinePrime{T}(a)\n\nyields a kernel instance that is the 1st derivative of the Keys cardinal cubic spline (see CardinalCubicSpline) for floating-point type T and parameter a.  This derivative is given by:\n\nker′(x) = (3(a + 2)*|x| - 2(a + 3))*x           if |x| ≤ 1\n          (3a)*(|x| - 2)*(|x| - 4/3)*sign(x)    if 1 ≤ |x| ≤ 2\n          0                                     if |x| ≥ 2\n\n\n\n\n\n","category":"type"},{"location":"library/#Catmull-Rom-interpolation-kernel-1","page":"Reference","title":"Catmull-Rom interpolation kernel","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"CatmullRomSpline\nCatmullRomSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.CatmullRomSpline","page":"Reference","title":"InterpolationKernels.CatmullRomSpline","text":"CatmullRomSpline{T}()\n\nyields an instance of the Catmull-Rom interpolation kernel for floating-point type T which is assumed to be Float64 if omitted.\n\nCatmull-Rom interpolation kernel is a cardinal piecewise cubic spline defined by:\n\nker(x) = ((3/2)*|x| - (5/2))*x^2 + 1             if |x| ≤ 1\n         (((5/2) - (1/2)*|x|)*|x| - 4)*|x| + 2   if 1 ≤ |x| ≤ 2\n         0                                       if |x| ≥ 2\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the Catmull-Rom interpolation kernel ker (also see the constructor CatmullRomSplinePrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.CatmullRomSplinePrime","page":"Reference","title":"InterpolationKernels.CatmullRomSplinePrime","text":"CatmullRomSplinePrime{T}()\n\nyields a kernel instance that is the 1st derivative of the Catmull-Rom interpolation kernel (see CatmullRomSpline) for floating-point type T which is assumed to be Float64 if omitted.\n\nThe 1st derivative of the Catmull-Rom interpolation kernel is given by:\n\nker′(x) = ((9/2)*|x| - 5)*x                      if a = |x| ≤ 1\n          (5 - (3/2)*|x|)*x - 4*sign(x)          if 1 ≤ |x| ≤ 2\n          0                                      if |x| ≥ 2\n\n\n\n\n\n","category":"type"},{"location":"library/#Mitchell-Netravali-kernels-1","page":"Reference","title":"Mitchell-Netravali kernels","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"MitchellNetravaliSpline\nMitchellNetravaliSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.MitchellNetravaliSpline","page":"Reference","title":"InterpolationKernels.MitchellNetravaliSpline","text":"MitchellNetravaliSpline{T}(b=1/3, c=1/3)\n\nyields an instance of the Mitchell & Netravali family of kernels for floating-point type T and parameters (b,c).\n\nThese kernels are cubic splines which depends on 2 parameters, b and c. Whatever the values of (b,c), Mitchell & Netravali kernels are normalized, even and C¹ continuous functions (these kernels and their first derivatives are continuous).\n\nTaking b = 0 yields the family of cardinal cubic splines (see CardinalCubicSpline) and is a sufficient and necessary condition to have Mitchell & Netravali kernels be cardinal functions.\n\nUsing the constraint: b + 2c = 1 yields a cubic filter with, at least, quadratic order approximation.\n\nSome specific values of (b,c) yield other well known kernels:\n\n(b,c) = (1,0)      --> cubic B-spline\n(b,c) = (0,-a)     --> Keys's cardinal cubic spline CardinalCubicSpline(a)\n(b,c) = (0,1/2)    --> Catmull-Rom kernel CatmullRomSpline()\n(b,c) = (b,0)      --> Duff's tensioned B-spline\n(b,c) = (6β,-α-3β) --> generic cubic spline CubicSpline(α,β)\n(b,c) = (1/3,1/3)  --> recommended by Mitchell-Netravali\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the Mitchell & Netravali kernel ker (also see the constructor MitchellNetravaliSplinePrime).\n\nMitchell & Netravali family of kernels are currently instances of CubicSpline.\n\nReference:\n\nMitchell & Netravali, \"Reconstruction Filters in Computer Graphics\", in Computer Graphics, Vol. 22, Num. 4 (1988).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.MitchellNetravaliSplinePrime","page":"Reference","title":"InterpolationKernels.MitchellNetravaliSplinePrime","text":"MitchellNetravaliSplinePrime([T=Float64,] [b=1/3, c=1/3,] B=Flat)\n\nyields a kernel instance that is the 1st derivative of the Mitchell & Netravali kernel (see MitchellNetravaliSpline) for floating-point type T, parameters b and c and boundary conditions B.\n\n\n\n\n\n","category":"type"},{"location":"library/#Lanczos-re-sampling-kernels-1","page":"Reference","title":"Lanczos re-sampling kernels","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"LanczosKernel\nLanczosKernelPrime","category":"page"},{"location":"library/#InterpolationKernels.LanczosKernel","page":"Reference","title":"InterpolationKernels.LanczosKernel","text":"LanczosKernel{S,T}()\n\nyields an instance of a Lanczos re-sampling kernel of support size S (which must be even) and for floating-point type T.\n\nThe Lanczos re-sampling kernels are even cardinal functions which tend to be normalized for large support size.  They are defined by:\n\nker(x) = S/(2*(π*x)^2)*sin(π*x)*sin(2*π*x/S)     if |x| ≤ S/2\n         0                                       if |x| ≥ S/2\n\nThe expression ker' yields the first derivative of a Lanczos re-sampling kernel ker (also see the constructor LanczosKernelPrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.LanczosKernelPrime","page":"Reference","title":"InterpolationKernels.LanczosKernelPrime","text":"LanczosKernelPrime{S,T}()\n\nyields a kernel instance that is the 1st derivative of the Lanczos re-sampling kernel (see LanczosKernel) of support size S and for floating-point type T.\n\n\n\n\n\n","category":"type"},{"location":"basics/#Basic-usage-1","page":"Basic usage","title":"Basic usage","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"An interpolation kernel Kernel{T,S} is parametrized by the floating-point type T of its coefficients and by the (integer) size S of its support.  For efficiency reasons, only kernels with (small) finite size supports are implemented.  To create a kernel instance, call its constructor; for example:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"ker = LanczosKernel{6}()","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"yields a Lanczos re-sampling kernel of size 6 (see Interpolation kernels for an exhaustive list of kernels implemented in InterpolationKernels) and using floating-point tytpe Float64 for computations.  The same kind of kernel with a specific floating-point type, say T, is created as:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"ker = LanczosKernel{6,T}()","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Any interpolation kernel ker is a callable object which may be used as a function with a real argument:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"ker(x::Real)","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"yields kernel value at x.  In InterpolationKernels, all kernel supports are symmetric; that is ker(x) is zero if abs(x) > S/2 with S the size of the kernel support.","category":"page"},{"location":"basics/#Basic-methods-1","page":"Basic usage","title":"Basic methods","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Some simple methods are available for any interpolation kernel ker:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"eltype(ker) yields the floating-point type T for calculations;\nlength(ker) yields the number S of samples in the support of ker which is also the number of neighbors involved in an interpolation by this kernel;","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Since the floating-point type T and the support size S are parameters of the interpolation kernel type, the above methods can also be applied to the type of an interpolation kernel.","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Some interpolation kernels have numerical parameters, these parameters can be retrieved by:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"values(ker)","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"which yields a tuple of parameters, possibly empty.  A kernel instance identical to ker can be built as follows:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"typeof(ker)(values(ker)...)","category":"page"},{"location":"basics/#Kernel-floating-point-type-1","page":"Basic usage","title":"Kernel floating-point type","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Calling a kernel ker with a real argument x, as ker(x), always yield a floating-point of type T = eltype(ker).  This property has been imposed for efficiency reasons when interpolating arrays.  Calling a kernel ker with an argument x that has a different floating-point type is therefore less efficient as it involves converting the value of the real x.  It is however very easy to change the floating-point type used by a kernel.","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"A kernel object ker can be converted to use a given floating-point type. For example, assuming ker is a kernel instance, one can do either of:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"convert(Kernel{Float32}, ker)\nKernel{Float32}(ker)\nFloat32(ker)","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"to use Float32 floating-point arithmetic with ker.","category":"page"},{"location":"basics/#Traits-1","page":"Basic usage","title":"Traits","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Methods iscardinal and isnormalized can be used to query whether a kernel is a cardinal function (that is a function which yields zero for all non-zero integers) and whether a kernel has the partition of unity property.  For some parametric kernels, these traits depend on the specific values of the parameters so these methods take a kernel instance (not a type) as argument.","category":"page"},{"location":"basics/#Derivative-1","page":"Basic usage","title":"Derivative","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"The expression ker' yields a kernel instance which is the 1st derivative of the kernel ker.  Having the derivative of a kernel is useful in a number of practical cases.  For instance, thanks to linearity of the interpolation procedure, interpolating an array A with the derivative ker' is equivalent to taking the 1st derivative of the continuous function modeled by interpolating the array A with the kernel ker.","category":"page"},{"location":"basics/#Interpolation-weights-1","page":"Basic usage","title":"Interpolation weights","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Efficient computation of interpolation weights is implemented by the InterpolationKernels.compute_offset_and_weights InterpolationKernels.compute_weights methods.  These methods are not exported because they are only required to implement array interpolation, as done by the FineShift or LinearInterpolators packages. The principles of interpolation are detailed in another section.","category":"page"},{"location":"install/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"InterpolationKernels is not yet an offical Julia package but its installation can be as easy as:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> add https://github.com/emmt/InterpolationKernels.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"where … pkg> represents the package manager prompt (the ellipsis … denote your current environment).  To start Julia's package manager, launch Julia and, at the REPL of Julia, hit the ] key; you should get the above … pkg> prompt.  To revert to Julia's REPL, just hit the Backspace key at the … pkg> prompt.","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"More detailed explanations are given below.","category":"page"},{"location":"install/#Using-the-package-manager-1","page":"Installation","title":"Using the package manager","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"InterpolationKernels can be installed by Julia's package manager using https protocol:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> add https://github.com/emmt/InterpolationKernels.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"or ssh protocol:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> add git@github.com:emmt/InterpolationKernels.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"To check whether the InterpolationKernels package works correctly, type:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> test InterpolationKernels","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"Later, to update to the last version (and run tests), you can type:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> update InterpolationKernels\n… pkg> test InterpolationKernels","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"If something goes wrong, it may be because you already have an old version of InterpolationKernels.  Uninstall InterpolationKernels as follows:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"… pkg> rm InterpolationKernels\n… pkg> gc\n… pkg> add https://github.com/emmt/InterpolationKernels.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"before re-installing.","category":"page"},{"location":"install/#Installation-in-scripts-1","page":"Installation","title":"Installation in scripts","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"To install InterpolationKernels in a Julia script, write:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/emmt/InterpolationKernels.jl\",\n                    rev=\"master\"));","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"or with url=\"git@github.com:emmt/InterpolationKernels.jl\" if you want to use ssh.","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"This also works from the Julia REPL.","category":"page"},{"location":"interpolation/#Interpolation-1","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Interpolation kernels, as their name suggest, are designed for interpolating arrays.  The InterpolationKernels package provides the method InterpolationKernels.compute_offset_and_weights to efficiently compute interpolation weights for a given kernel and interpolating position.","category":"page"},{"location":"interpolation/#Interpolation-principles-1","page":"Interpolation","title":"Interpolation principles","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"To explain how linear interpolation works, let us assume that we want to interpolate a source vector A ∈ 𝕂ⁿ using the kernel h: ℝ → ℝ to produce a continuous model function f(x) with x ∈ ℝ the continuous coordinate. Such a model writes:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"∀ x ∈ ℝ:    f(x) = sum_{k ∈ ℤ} h(x - k)*ℬ(A,k)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where sum_{k ∈ ℤ} denotes a sum over all integers and ℬ: 𝕂ⁿ×ℤ → 𝕂 implements the boundary conditions with Sup(A) the set of valid indices for A.  In Julia code, Sup(A) = axes(A,1) and n = length(A).  The above equation is a discrete convolution of A by the kernel h.  The model function is f: ℝ → 𝕂 where 𝕂 is the field of the values taken by the product in the above sum.  We make no restrictions for the boundary conditions except that the following always holds:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"∀ k ∈ Sup(A):    ℬ(A,k) = A[k]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"For instance, flat boundaries are implemented by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"          / A[min(Sup(A))]  if k ≤ min(Sup(A))\nℬ(A,k) = |  A[max(Sup(A))]  if k ≥ max(Sup(A))\n          \\ A[k]            else","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Provided the kernel h has a finite size support, we can assume (without loss of generality) that the kernel support Sup(h) is enclosed in a right-open interval of nonzero integer width s ∈ ℕ \\ {0}.  That is, there exists a ∈ ℝ such that Sup(h) ⊂ [a,b) with b = a + s.  In other words:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"x < a   or   x ≥ b    ⟹     h(x) = 0","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"The indices k ∈ ℤ such that h(x-k) is not certainly zero are:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"k ∈ ℤ, x-k ∈ [a,b)\n⟺    k ∈ ℤ ∩ (x-b, x-a]\n⟺    k ∈ ⟦⌊x-b+1⌋, ⌊x-a⌋⟧","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with ⌊…⌋ the floor function.  Since the objective is to have the smallest interval to restrict the number of terms in the discrete convolution, it may be better to enclose the kernel support in a left-open interval, that is Sup(h) ⊂ (a,b], the set of indices k such that h(x-k) is not certainly zero is then given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"k ∈ ℤ, x-k ∈ (a,b]\n⟺    k ∈ ℤ ∩ [x-b, x-a)\n⟺    k ∈ ⟦⌈x-b⌉, ⌈x-a-1⌉⟧","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with ⌈…⌉ the ceil function.  To summarize, the discrete convolution in the model f(x) can be limited to indices k ∈ ⟦kmin(x),kmax(x)⟧ where:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"kmin(x) = ⌊x-b+1⌋    if Sup(h) ⊂ [a,b)\n          ⌈x-b⌉      if Sup(h) ⊂ (a,b]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"and kmax(x) = kmin(x) + s - 1 (either of these above expressions can be chosen if Sup(h) ⊂ (a,b)).  The interpolation formula can finally be rewritten as:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"∀ x ∈ ℝ:    f(x) = sum_{j ∈ jmin:jmax} w_j(x)*ℬ(A, l(x) + j)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where k = l(x) + j and w_j(x) = h(x-k) for j ∈ ⟦jmin,jmax⟧ account for all the non-zero terms of the sum in the original formula.  Hence jmax = jmin+s-1 and:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"  l(x) = kmin(x) - jmin\nw_j(x) = h(x - l(x) - j)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Note that jmin ∈ ℤ can be chosen as is the most convenient.  For instance, assuming Julia or Fortran indexing, one would choose jmin = 1 and thus l(x) = ⌊x-b⌋ if Sup(h) ⊂ [a,b).","category":"page"},{"location":"interpolation/#Methods-and-structures-1","page":"Interpolation","title":"Methods and structures","text":"","category":"section"},{"location":"interpolation/#General-methods-1","page":"Interpolation","title":"General methods","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"The above developments suggest that, for any interpolation kernel h and interpolation coordinate x, we mostly need a function that yields the offset l(x) and the interpolation weights w_j(x) for all j ∈ ⟦jmin,jmax⟧.  This is exactly what is done by the method compute_offset_and_weights provided by the InterpolationKernels package. This method is called as:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"off, wgt = compute_offset_and_weights(h, x)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with h the interpolation kernel, x the coordinate, off = l(x) the offset and wgt the s-tuple of interpolation weights given by wgt[j] = w_j(x). In Julia, the first index of tuples is 1, so we have jmin = 1 and thus:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"off = kmin(x) - 1 = ⌊x-b⌋          if Sup(h) ⊂ [a,b)\n                    ⌈x-b⌉ - 1      if Sup(h) ⊂ (a,b]\nwgt[j] = h(x - off - j)            for j = 1, 2, ..., s","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"In order to compute the offset, the coordinate x but also the support of the kernel h must be known.  These are the reasons to have interpolation kernels in InterpolationKernels be defined as smart functions that know their support.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Assuming the following methods are available (they are indeed defined in InterpolationKernels but not exported):","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"support(ker) ---> sup # the kernel support `Sup(ker)`\nlength(sup) ----> s   # the integer size of the kernel support\ninfimum(sup) ---> a   # the least upper bound of the support `sup`\nsupremum(sup) --> b   # the greatest lower bound of the support `sup`","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"the offset off can be computed by (there are two cases to consider):","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"offset(sup::Support{T,S,<:Bound,Open}, x::T) where {T,S} =\n    floor(x - supremum(sup))       #  if Sup(ker) is ⊂ [a,b)\noffset(sup::Support{T,S,Open,Closed}, x::T) where {T,S} =\n    ceil(x - (supremum(sup) - 1))  #  if Sup(ker) is ⊂ (a,b]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"and a generic implementation of compute_offset_and_weights is given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"compute_offset_and_weights(ker::Kernel{T}, x::T) where {T} =\n    compute_offset_and_weights(support(ker), ker, x)\n\nfunction compute_offset_and_weights(sup::Support{T,S},\n                                    ker::Kernel{T,S}, x::T) where {T,S}\n    off = offset(sup, x)\n    return off, ntuple(j -> ker(x - off - j), Val(length(ker)))\nend","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Of course compute_offset_and_weights is optimized for the most popular kernels in order to reduce the number of operations.  But the generic code above gives you the ideas.","category":"page"},{"location":"interpolation/#Symmetric-supports-1","page":"Interpolation","title":"Symmetric supports","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"For kernels with symmetric support, the following hold a = -b and b = s/2. The interpolation weights can be then expressed as:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"wgt[j] = h(t - j)        for j ∈ 1-m:s-m","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with m = (s+1)>>1 (that is the integer division of s+1 by 2) and:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"t = x - floor(x)      if s is even\n    x - round(x)      if s is odd","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"and the offset is given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"off = floor(x) - m      if s is even\n      round(x) - m      if s is odd","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"These expressions are used by compute_offset_and_weights for kernels with symmetric support because they may help reducing the number of operations (at least for splines) for computing interpolation weights.  In that case, the weights are computed by calling compute_weights with the kernel and the computed value of t (not x):","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"wgt = compute_weights(k, t)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"When a new kernel is implemented, compute_offset_and_weights or, if the kernel has a symmetric support, compute_weights may be specialized to optimize computations.","category":"page"},{"location":"interpolation/#Example:-fine-shifting-1","page":"Interpolation","title":"Example: fine shifting","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Let us now assume that we want to compute:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"C[i] ≈ A[i - r]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"for all indices i ∈ Sub(C) of the destination vector C and some non-integer offset r where ≈ denotes the approximation by the interpolation model f(x) described above.  Hence C is the result of performing a sub-sample shift of A by offset r.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Combining equations (that is just replace x by i-r in the interpolation formula) yields:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"C[i] = f(i - r)\n     = sum_{j ∈ 1:s} h(i - r - l(i - r) - j)*ℬ(A, l(i - r) + j)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"From the definition of the offset l(x) it is obvious that:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"∀ (r,i) ∈ ℝ×ℤ:    l(i - r) = i + l(-r) = i - k","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"k = -l(-r)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Hence the interpolation writes:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"C[i] = sum_{j ∈ 1:s} h(k - r - j)*ℬ(A, i - k + j)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"But as v = k - r is a constant that does not depend on i, the weights:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"W[j] = h(k - r - j) = h(v - j)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"can be computed once for all indices i in the destination B to perform fine shifting by the following formula:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"C[i] = sum_{j ∈ 1:s} W[j]*ℬ(A, i - k + j)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"which is a discrete correlation of W and A.  The weights W and the integer offset k do not depend on i, resulting in very fast computations. This is exploited by the FineShift package.","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The InterpolationKernels package provides a library of interpolation kernels for Julia.  As suggested by their name, interpolations kernels are mostly designed for interpolation, they can be thought as smart functions that know their derivative and that implement optimized computation of interpolation weights.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The source code is on GitHub.","category":"page"},{"location":"#Table-of-contents-1","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"install.md\", \"basics.md\", \"kernels.md\",\n         \"interpolation.md\", \"library.md\"]","category":"page"},{"location":"#Index-1","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
