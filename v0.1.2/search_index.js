var documenterSearchIndex = {"docs":
[{"location":"kernels/#Kernels-1","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"InterpolationKernels provide the following kernels:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Name Support Cardinal Parameters Description\nRectangularSpline 1 yes  \nLinearSpline 2 yes  linear B-spline\nQuadraticSpline 3 no  quadratic B-spline\nCubicSpline 4 no  cubic B-spline\nCatmullRomSpline 4 yes  Catmull-Rom kernels\nCardinalCubicSpline 4 yes a \nKeysSpline 4 yes a Keys cardinal kernels\nMitchellNetravaliSpline 4 yes/no b, c Mitchell & Netravali kernels\nLanczosKernel S yes S Lanczos re-sampling kernels","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"In this table, the Cardinal column indicates whether a kernel ker(x) is a cardinal function, that is ker(k) = 0 for all integers k except that ker(0) = 1 which makes such a kernel suitable for interpolation.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"A spline is defined as a piecewise polynomial of given degree.  A B-spline is a spline which is everywhere nonnegative, an even and normalized function (its integral is equal to 1).","category":"page"},{"location":"kernels/#Rectangular-Spline-1","page":"Kernels","title":"Rectangular Spline","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The rectangular spline (also known as box kernel or Fourier window or Dirichlet window) is the 1st order (constant) B-spline equals to 1 on [-1/2,+1/2), and 0 elsewhere.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"A rectangular spline instance is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = RectangularSpline([T=Float64,] B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Its derivative is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"dker = RectangularSplinePrime([T=Float64,] B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"or by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"dker = ker'","category":"page"},{"location":"kernels/#Linear-B-spline-1","page":"Kernels","title":"Linear B-spline","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The linear spline (also known as triangle kernel or Bartlett window or Fejér window) is the 2nd order (linear) B-spline.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"A linear spline instance is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = LinearSpline([T=Float64,] B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Its derivative is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"dker = LinearSplinePrime([T=Float64,] B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"or by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"dker = ker'","category":"page"},{"location":"kernels/#Quadratic-B-spline-1","page":"Kernels","title":"Quadratic B-spline","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The quadratic spline is the 3rd order (quadratic) B-spline.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"A quadratic spline instance is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"QuadraticSpline([T=Float64,] B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Its derivative is created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"QuadraticSplinePrime([T=Float64,] B=Flat)","category":"page"},{"location":"kernels/#Cubic-B-spline-1","page":"Kernels","title":"Cubic B-spline","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The 4th order (cubic) B-spline kernel is defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = (|x|/2 - 1)*|x|^2 + 2/3     if |x| ≤ 1\n         (1/6)*(2 - |x|)^3           if 1 ≤ |x| ≤ 2\n         0                           if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The cubic B-spline is also known as Parzen window or as de la Vallée Poussin window.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The cubic B-spline is a function of class C² (its derivatives up to the second one are everywhere continuous), its first derivative is given by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker'(x) = ...","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a cubic B-spline, call:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = CubicSpline([T=Float64,] B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where optional arguments are the floating-point type T<:AbstractFloat and the boundary conditions B< Boundaries (their order is irrelevant).","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of the derivative of a cubic B-spline, call one of:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"kerp = ker'\nkerp = CubicSplinePrime([T=Float64,] B=Flat)","category":"page"},{"location":"kernels/#Catmull-Rom-kernel-1","page":"Kernels","title":"Catmull-Rom kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The Catmull-Rom kernel is a special case of Mitchell & Netravali kernel.  It is a piecewise cardinal cubic spline defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = ((3/2)*|x| - (5/2))*x^2 + 1             if |x| ≤ 1\n         (((5/2) - (1/2)*|x|)*|x| - 4)*|x| + 2   if 1 ≤ |x| ≤ 2\n         0                                       if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Being a cardinal function, the Catmull-Rom kernel is suitable for interpolation.  Its derivative is given by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker′(x) = ((9/2)*|x| - 5)*x                      if a = |x| ≤ 1\n          (5 - (3/2)*|x|)*x - 4*sign(x)          if 1 ≤ |x| ≤ 2\n          0                                      if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a Catmull-Rom interpolation kernel, call","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = CatmullRomSpline([T=Float64,] B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where optional arguments are the floating-point type T and the boundary conditions B.  To create an instance of the derivative of a Catmull-Rom interpolation kernel, call one of:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"kerp = ker'\nkerp = CatmullRomSplinePrime([T=Float64,] B=Flat)","category":"page"},{"location":"kernels/#Cardinal-cubic-spline-1","page":"Kernels","title":"Cardinal cubic spline","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"CardinalCubicSpline([T=Float64,] c, B=Flat) -> ker","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"yields a cardinal cubic spline interpolation kernel for floating-point type T tension parameter c and boundary conditions B.  The slope at x = ±1 is ±(c - 1)/2.  Usually c ≤ 1, choosing c = 0 yields a Catmull-Rom spline, c = 1 yields all zero tangents, c = -1 yields a truncated approximation of a cardinal sine, c = -1/2 yields an interpolating cubic spline with continuous second derivatives (inside its support).","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Its derivative is given by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"CardinalCubicSplinePrime([T=Float64,] c, B=Flat) -> ker","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = |x| < 1 ? ((r*|x| - 1)*|x| - 1)*(|x| - 1) :\n         |x| < 2 ? p*(|x| - 1)*(2 - |x|)^2            : 0","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"with p = ... and r = ....","category":"page"},{"location":"kernels/#Keys-cardinal-kernels-1","page":"Kernels","title":"Keys cardinal kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Keys kernels are parametric cardinal cubic splines defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = p(|x|)   if |x| ≤ 1\n         q(|x|)   if 1 ≤ |x| ≤ 2\n         0        if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"with:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"p(x) = 1 - (a + 3)*x^2 + (a + 2)*x^3\nq(x) = -4a + 8a*x - 5a*x^2 + a*x^3","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"These kernels are piecewise normalized cardinal cubic spline which depend on one parameter a which is the slope of the spline at abscissa 1.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The first derivative of a Keys spline is defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker′(x) = p′(|x|)*sign(x)   if |x| ≤ 1\n          q′(|x|)*sign(x)   if 1 ≤ |x| ≤ 2\n          0                 if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"with:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"p'(x) = -2*(a + 3)*x + 3*(a + 2)*x^2\nq'(x) = 8a - 10a*x + 3a*x^2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a Keys spline with parameter a, call:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker = KeysSpline([T=Float64,] a, B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where optional parameters are the floating-point type T and the boundary conditions B.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of a Keys kernel ker.  An instance of the first derivative of a Keys kernel can also be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"KeysSplinePrime([T=Float64,] a, B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Reference:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Keys, Robert, G., \"Cubic Convolution Interpolation for Digital Image Processing\", IEEE Trans. Acoustics, Speech, and Signal Processing, Vol. ASSP-29, No. 6, December 1981, pp. 1153-1160.","category":"page"},{"location":"kernels/#Mitchell-and-Netravali-kernels-1","page":"Kernels","title":"Mitchell & Netravali kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Mitchell & Netravali kernels are cubic splines which depends on 2 parameters, b and c.  Whatever the values of (b,c), all these kernels are normalized and even functions of class C¹ (these kernels and their first derivatives are continuous).","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Taking b = 0 yields Keys's family of kernels and is a sufficient and necessary condition to have Mitchell & Netravali kernels be cardinal functions.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Using the constraint: b + 2c = 1 yields a cubic filter with, at least, quadratic order approximation.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Some specific values of (b,c) yield other well known kernels:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"(b,c) = (1,0)     ==> cubic B-spline\n(b,c) = (0,-a)    ==> Keys's cardinal cubics\n(b,c) = (0,1/2)   ==> Catmull-Rom cubics\n(b,c) = (b,0)     ==> Duff's tensioned B-spline\n(b,c) = (1/3,1/3) ==> recommended by Mitchell-Netravali","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Mitchell & Netravali kernels are defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = p(|x|)      if |x| ≤ 1\n         q(|x|)      if 1 ≤ |x| ≤ 2\n         0           if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"with:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"p(x) = (p3*x + p2)*x*x + p0\nq(x) = ((q3*x + q2)*x + q1)*x + q0","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"and:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"p0 =  1 - b/3\np2 = -3 + 2b + c\np3 =  2 - 3b/2 - c\nq0 =  4b/3 +4*c\nq1 = -2b - 8c\nq2 =  b + 5c\nq3 =  -b/6 - c","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The first derivative of a Mitchell & Netravali kernel is given by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker'(x) = sign(x)*p'(|x|)      if |x| ≤ 1\n          sign(x)*q'(|x|)      if 1 ≤ |x| ≤ 2\n          0                    if |x| ≥ 2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"with:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"p'(x) = (dp2*x + dp1)*x\nq'(x) = ((dq3*x + dq2)*x + dq1)*x","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"dp1 = 2*p2 = -6 + 4b + 2c\ndp2 = 3*p3 =  6 - 9b/2 - 3c\ndq0 =   q1 = -2b - 8c\ndq1 = 2*q2 = 2b + 10c\ndq2 = 3*q3 = -b/2 - 3c","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a Mitchell & Netravali kernel, call:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"MitchellNetravaliSpline([T=Float64,] [b=1/3, c=1/3,] B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where optional parameters are the floating-point type T, the family parameters b and c and the boundary conditions B.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of a Mitchell & Netravali kernel ker.  An instance of the first derivative of a Mitchell & Netravali kernel can also be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"MitchellNetravaliSplinePrime([T=Float64,] [b=1/3, c=1/3,] B=Flat) -> ker","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Reference:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"Mitchell & Netravali, \"Reconstruction Filters in Computer Graphics\", in Computer Graphics, Vol. 22, Num. 4 (1988) pdf.","category":"page"},{"location":"kernels/#Lanczos-re-sampling-kernels-1","page":"Kernels","title":"Lanczos re-sampling kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The Lanczos re-sampling kernels are defined by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"ker(x) = (S/2π²)*sin(π*x)*sin(2π*x/S)/x^2","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The Lanczos re-sampling kernels are even cardinal functions which tend to be normalized for large support size (see this Wikipedia page).","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"To create an instance of a Lanczos re-sampling kernel of support size S (which must be even), call:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"LanczosKernel([T=Float64,] S, B=Flat)","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"where optional parameters are the floating-point type T and the boundary conditions B.","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"The expression ker' yields the first derivative of a Lanczos re-sampling kernel ker.  An instance of the first derivative of a Lanczos re-sampling kernel can also be directly created by:","category":"page"},{"location":"kernels/#","page":"Kernels","title":"Kernels","text":"LanczosKernelPrime([T=Float64,] S, B=Flat)","category":"page"},{"location":"library/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"The following provides detailled documentation about types and methods provided by the InterpolationKernels package.  This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"library/#Methods-1","page":"Reference","title":"Methods","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"iscardinal\nisnormalized\nbrief\ngetweights","category":"page"},{"location":"library/#InterpolationKernels.iscardinal","page":"Reference","title":"InterpolationKernels.iscardinal","text":"iscardinal(ker)\n\nyields whether the kernel ker is zero for non-zero integer arguments. Cardinal kernels are directly suitable for interpolation.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.isnormalized","page":"Reference","title":"InterpolationKernels.isnormalized","text":"isnormalized(ker)\n\nyields whether the kernel ker has the partition of unity property.  That is, the sum of the values computed by the kernel ker on a unit spaced grid is equal to one.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.brief","page":"Reference","title":"InterpolationKernels.brief","text":"brief(ker)\n\nyields a brief description of the kernel ker.\n\n\n\n\n\n","category":"function"},{"location":"library/#InterpolationKernels.getweights","page":"Reference","title":"InterpolationKernels.getweights","text":"getweights(ker, x - j) -> w1, w2, ..., wS\n\nyields the S-tuple of the weights for interpolating around position x (in fractional index units) with kernel ker (S is the size of the kernel support).  The index j is given by:\n\nj = floor(x)   #  if `S` is even\nj = round(x)   #  if `S` is odd\n\n(the rounding direction does not matter for the result of the interpolation). The offset t = x - j is therefore in the range [0,1] for S even and in the range [-1/2,+1/2] for S odd.\n\n\n\n\n\n","category":"function"},{"location":"library/#Boundary-conditions-1","page":"Reference","title":"Boundary conditions","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"Boundaries\nFlat\nSafeFlat\nboundaries","category":"page"},{"location":"library/#InterpolationKernels.Boundaries","page":"Reference","title":"InterpolationKernels.Boundaries","text":"All extrapolation methods (a.k.a. boundary conditions) are singletons and inherit from the abstract type Boundaries.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.Flat","page":"Reference","title":"InterpolationKernels.Flat","text":"Type Flat indicates that flat boundary conditions hold.  These conditions assume that the value of the nearest sample is used when extrapolating.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.SafeFlat","page":"Reference","title":"InterpolationKernels.SafeFlat","text":"Type SafeFlat indicates that flat boundary conditions hold.  These conditions as similar to the ones assumed by Flat conditions but are safer because they account for possible integer overflows when converting coordinates to indices.  As a consequence, applying SafeFlat boundary conditions is slower than applying Safe boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.boundaries","page":"Reference","title":"InterpolationKernels.boundaries","text":"boundaries(ker)\n\nyields the type of the boundary conditions that hold for extrapolation with kernel ker.\n\n\n\n\n\n","category":"function"},{"location":"library/#Kernels-1","page":"Reference","title":"Kernels","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"Kernel","category":"page"},{"location":"library/#InterpolationKernels.Kernel","page":"Reference","title":"InterpolationKernels.Kernel","text":"Interpolation Kernels\n\nAn interpolation kernel Kernel{T,S,B} is parametrized by the floating-point type T of its coefficients, by the size S of its support and by the boundary conditions B to apply for extrapolation.  For efficiency reasons, only kernels with (small) finite size supports are implemented.\n\nA kernel ker is a callable object which may be used as a function with a real argument:\n\nker(x::Real)\n\nyields kernel value at offset x.  All kernel supports are symmetric; that is ker(x) is zero if abs(x) > S/2 with S the size of the kernel support.\n\nKernel conversion\n\nThe argument of a kernel be a floating-point type and/or a boundary conditions type:\n\nker(::Type{T}, ::Type{B}) where {T<:AbstractFloat, B<:Boundaries}\n\nto convert the kernel to operate with given floating-point type T and use boundary conditions B (any of which can be omitted and their order is irrelevant).  Beware that changing the floating-point type may lead to a loss of precision if the new floating-point type has more digits).\n\nIt is possible to change the floating-point type of a kernel or its boundary conditions by something like:\n\nFloat32(ker)    # change floating-point type of kernel `ker`\nSafeFlat(ker)   # change boundary conditions of kernel `ker`\n\nThe above calls do not follow the usuall conventions that a constructor may be called to convert its argument(s) to an instance of its type, this is however practical considering the following more rigorous calls to repectively change the the floating-point type and boundary conditions of kernel ker:\n\nconvert(Kernel{Float32}, ker)\nconvert(Kernel{eltype(ker),length(ker),SafeFlat}, ker)\n\nAvailable methods\n\nThe following methods are available for any interpolation kernel ker:\n\neltype(ker) -> T\n\nyields the floating-point type for calculations,\n\nlength(ker) -> S\nsize(ker)   -> (S,)\n\nyield the size the support of ker which is also the number of neighbors involved in an interpolation by this kernel,\n\nboundaries(ker) -> B\n\nyields the type of the boundary conditions applied for extrapolation; finally:\n\ngetweights(ker, t) -> w1, w2, ..., wS\n\nyields the S interpolation weights for offset t\n\nt = x - floor(x)        if s is even\n    x - round(x)        if s is odd\n\nt ∈ [0,1] if S is even or for offset t ∈ [-1/2,+1/2] if S is odd.\n\n\n\n\n\n","category":"type"},{"location":"library/#Rectangular-B-spline-1","page":"Reference","title":"Rectangular B-spline","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"RectangularSpline\nRectangularSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.RectangularSpline","page":"Reference","title":"InterpolationKernels.RectangularSpline","text":"RectangularSpline([T=Float64,] B=Flat)\n\nyields an instance of the rectangular spline for floating-point type T and boundary conditions B.\n\nThe rectangular spline (also known as box kernel, as Fourier window or as Dirichlet window) is the 1st order (constant) B-spline equals to 1 on [-1/2,+1/2), and 0 elsewhere.\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the rectangular spline ker (also see the constructor RectangularSplinePrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.RectangularSplinePrime","page":"Reference","title":"InterpolationKernels.RectangularSplinePrime","text":"RectangularSplinePrime([T=Float64,] B=Flat)\n\nyields a kernel instance that is the 1st derivative of the rectangular spline (see RectangularSpline) for floating-point type T and boundary conditions B.\n\n\n\n\n\n","category":"type"},{"location":"library/#Linear-B-spline-1","page":"Reference","title":"Linear B-spline","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"LinearSpline\nLinearSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.LinearSpline","page":"Reference","title":"InterpolationKernels.LinearSpline","text":"LinearSpline([T=Float64,] B=Flat)\n\nyields an instance of the linear spline for floating-point type T and boundary conditions B.\n\nThe linear spline (also known as triangle kernel, as Bartlett window or as Fejér window) is the 2nd order (linear) B-spline given by:\n\nker(x) = 1 - |x|       if |x| ≤ 1\n         0             if |x| ≥ 1\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the linear spline ker (also see the constructor LinearSplinePrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.LinearSplinePrime","page":"Reference","title":"InterpolationKernels.LinearSplinePrime","text":"LinearSplinePrime([T=Float64,] B=Flat)\n\nyields a kernel instance that is the 1st derivative of the linear spline (see LinearSpline) for floating-point type T and boundary conditions B.\n\n\n\n\n\n","category":"type"},{"location":"library/#Quadratic-B-spline-1","page":"Reference","title":"Quadratic B-spline","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"QuadraticSpline\nQuadraticSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.QuadraticSpline","page":"Reference","title":"InterpolationKernels.QuadraticSpline","text":"QuadraticSpline([T=Float64,] B=Flat)\n\nyields an instance of the quadratic spline for floating-point type T and boundary conditions B.\n\nThe quadratic spline is the 3rd order (quadratic) B-spline given by:\n\nker(x) = 3/4 - x^2                   if |x| ≤ 1/2\n         (1/2)*(|x| - 3/2)^2         if |x| ≤ 3/2\n         0                           if |x| ≥ 3/2\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the quadratic spline ker (also see the constructor QuadraticSplinePrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.QuadraticSplinePrime","page":"Reference","title":"InterpolationKernels.QuadraticSplinePrime","text":"QuadraticSplinePrime([T=Float64,] B=Flat)\n\nyields a kernel instance that is the 1st derivative of the quadratic spline (see QuadraticSpline) for floating-point type T and boundary conditions B.\n\n\n\n\n\n","category":"type"},{"location":"library/#Cubic-B-spline-1","page":"Reference","title":"Cubic B-spline","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"CubicSpline\nCubicSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.CubicSpline","page":"Reference","title":"InterpolationKernels.CubicSpline","text":"CubicSpline([T=Float64,] B=Flat)\n\nyields an instance of the cubic spline for floating-point type T and boundary conditions B.\n\nThe 4th order (cubic) B-spline kernel is also known as Parzen window or as de la Vallée Poussin window.   It is given by:\n\nker(x) = 2/3 + (|x|/2 - 1)*x^2       if |x| ≤ 1\n         (1/6)*(2 - |x|)^2           if |x| ≤ 2\n         0                           if |x| ≥ 2\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the cubic spline ker (also see the constructor CubicSplinePrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.CubicSplinePrime","page":"Reference","title":"InterpolationKernels.CubicSplinePrime","text":"CubicSplinePrime([T=Float64,] B=Flat)\n\nyields a kernel instance that is the 1st derivative of the cubic spline (see CubicSpline) for floating-point type T and boundary conditions B.\n\n\n\n\n\n","category":"type"},{"location":"library/#Catmull-Rom-interpolation-kernel-1","page":"Reference","title":"Catmull-Rom interpolation kernel","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"CatmullRomSpline\nCatmullRomSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.CatmullRomSpline","page":"Reference","title":"InterpolationKernels.CatmullRomSpline","text":"CatmullRomSpline([T=Float64,] B=Flat)\n\nyields an instance of the Catmull-Rom interpolation kernel for floating-point type T and boundary conditions B.\n\nCatmull-Rom interpolation kernel is a piecewise cardinal cubic spline defined by:\n\nker(x) = ((3/2)*|x| - (5/2))*x^2 + 1             if |x| ≤ 1\n         (((5/2) - (1/2)*|x|)*|x| - 4)*|x| + 2   if 1 ≤ |x| ≤ 2\n         0                                       if |x| ≥ 2\n\nCatmull-Rom kernel is a special case of Mitchell & Netravali kernel (see MitchellNetravaliSplinePrime).\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the Catmull-Rom interpolation kernel ker (also see the constructor CatmullRomSplinePrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.CatmullRomSplinePrime","page":"Reference","title":"InterpolationKernels.CatmullRomSplinePrime","text":"CatmullRomSplinePrime([T=Float64,] B=Flat)\n\nyields a kernel instance that is the 1st derivative of the Catmull-Rom interpolation kernel (see CatmullRomSpline) for floating-point type T and boundary conditions B.\n\nThe 1st derivative of the Catmull-Rom interpolation kernel is given by:\n\nker′(x) = ((9/2)*|x| - 5)*x                      if a = |x| ≤ 1\n          (5 - (3/2)*|x|)*x - 4*sign(x)          if 1 ≤ |x| ≤ 2\n          0                                      if |x| ≥ 2\n\n\n\n\n\n","category":"type"},{"location":"library/#Cardinal-cubic-splines-1","page":"Reference","title":"Cardinal cubic splines","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"CardinalCubicSpline\nCardinalCubicSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.CardinalCubicSpline","page":"Reference","title":"InterpolationKernels.CardinalCubicSpline","text":"CardinalCubicSpline([T=Float64,] c, B=Flat)\n\nyields an instance of a cardinal cubic spline interpolation kernel for floating-point type T, tension parameter c and boundary conditions B.\n\nThe slope at x = ±1 is ±(c - 1)/2.  Usually c ≤ 1, choosing c = 0 yields a Catmull-Rom spline (see CatmullRomSpline), c = 1 yields all zero tangents, c = -1 yields a truncated approximation of a cardinal sine, c = -1/2 yields an interpolating cubic spline with continuous second derivatives (inside its support).\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the cardinal cubic spline ker (also see the constructor CardinalCubicSplinePrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.CardinalCubicSplinePrime","page":"Reference","title":"InterpolationKernels.CardinalCubicSplinePrime","text":"CardinalCubicSplinePrime([T=Float64,] B=Flat)\n\nyields a kernel instance that is the 1st derivative of the cardinal cubic spline interpolation kernel (see CardinalCubicSpline) for floating-point type T, tension parameter c and boundary conditions B.\n\n\n\n\n\n","category":"type"},{"location":"library/#Keys-cardinal-kernels-1","page":"Reference","title":"Keys cardinal kernels","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"KeysSpline\nKeysSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.KeysSpline","page":"Reference","title":"InterpolationKernels.KeysSpline","text":"KeysSpline([T=Float64,] a, B=Flat)\n\nyields an instance of the Keys family of cardinal kernels for floating-point type T, parameter a and boundary conditions B.\n\nThese kernels are piecewise normalized cardinal cubic spline which depend on one parameter a which is the slope of the spline at abscissa 1.  Keys cardinal kernels are defined by:\n\nker(x) = p(abs(x))   if abs(x) ≤ 1\n         q(abs(x))   if 1 ≤ abs(x) ≤ 2\n         0           if abs(x) ≥ 2\n\nwith:\n\np(x) = 1 - (a + 3)*x^2 + (a + 2)*x^3\nq(x) = -4a + 8a*x - 5a*x^2 + a*x^3\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the Keys kernel ker (also see the constructor KeysSplinePrime).\n\nReference:\n\nKeys, Robert, G., \"Cubic Convolution Interpolation for Digital Image Processing\", IEEE Trans. Acoustics, Speech, and Signal Processing, Vol. ASSP-29, No. 6, December 1981, pp. 1153-1160.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.KeysSplinePrime","page":"Reference","title":"InterpolationKernels.KeysSplinePrime","text":"KeysSplinePrime([T=Float64,] a, B=Flat)\n\nyields a kernel instance that is the 1st derivative of the Keys kernel (see KeysSpline) for floating-point type T, parameter a and boundary conditions B.  This derivative is given by:\n\nker′(x) = p′(abs(x))*sign(x)   if abs(x) ≤ 1\n          q′(abs(x))*sign(x)   if 1 ≤ abs(x) ≤ 2\n          0                    if abs(x) ≥ 2\n\nwith:\n\np(x) = -2*(a + 3)*x + 3*(a + 2)*x^2\nq(x) = 8a - 10a*x + 3a*x^2\n\n\n\n\n\n","category":"type"},{"location":"library/#Mitchell-Netravali-kernels-1","page":"Reference","title":"Mitchell-Netravali kernels","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"MitchellNetravaliSpline\nMitchellNetravaliSplinePrime","category":"page"},{"location":"library/#InterpolationKernels.MitchellNetravaliSpline","page":"Reference","title":"InterpolationKernels.MitchellNetravaliSpline","text":"MitchellNetravaliSpline([T=Float64,] [b=1/3, c=1/3,] B=Flat)\n\nyields an instance of the Mitchell & Netravali family of kernels for floating-point type T, parameters b and c and boundary conditions B.\n\nThese kernels are cubic splines which depends on 2 parameters, b and c. Whatever the values of (b,c), all these kernels are normalized, even functions of class C¹ (these kernels and their first derivatives are continuous).\n\nTaking b = 0 yields Keys's family of kernels and is a sufficient and necessary condition to have Mitchell & Netravali kernels be cardinal functions.\n\nUsing the constraint: b + 2c = 1 yields a cubic filter with, at least, quadratic order approximation.\n\nSome specific values of (b,c) yield other well known kernels:\n\n(b,c) = (1,0)       ==> cubic B-spline\n(b,c) = (0,-a)      ==> Keys's cardinal cubics\n(b,c) = (0,(1-a)/2) ==> cardinal cubic spline\n(b,c) = (0,1/2)     ==> Catmull-Rom cubics\n(b,c) = (b,0)       ==> Duff's tensioned B-spline\n(b,c) = (1/3,1/3)   ==> recommended by Mitchell-Netravali\n\nThe expression ker' yields a kernel instance which is the 1st derivative of the Mitchell & Netravali kernel ker (also see the constructor MitchellNetravaliSplinePrime).\n\nReference:\n\nMitchell & Netravali, \"Reconstruction Filters in Computer Graphics\", in Computer Graphics, Vol. 22, Num. 4 (1988). http://www.cs.utexas.edu/users/fussell/courses/cs384g/lectures/mitchell/Mitchell.pdf.\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.MitchellNetravaliSplinePrime","page":"Reference","title":"InterpolationKernels.MitchellNetravaliSplinePrime","text":"MitchellNetravaliSplinePrime([T=Float64,] [b=1/3, c=1/3,] B=Flat)\n\nyields a kernel instance that is the 1st derivative of the Mitchell & Netravali kernel (see MitchellNetravaliSpline) for floating-point type T, parameters b and c and boundary conditions B.\n\n\n\n\n\n","category":"type"},{"location":"library/#Lanczos-re-sampling-kernels-1","page":"Reference","title":"Lanczos re-sampling kernels","text":"","category":"section"},{"location":"library/#","page":"Reference","title":"Reference","text":"LanczosKernel\nLanczosKernelPrime","category":"page"},{"location":"library/#InterpolationKernels.LanczosKernel","page":"Reference","title":"InterpolationKernels.LanczosKernel","text":"LanczosKernel([T=Float64,] S, B=Flat)\n\nyields an instance of a Lanczos re-sampling kernel of support size S (which must be even), for floating-point type T and boundary conditions B.\n\nThe Lanczos re-sampling kernels are even cardinal functions which tend to be normalized for large support size.  They are defined by (see also https://en.wikipedia.org/wiki/Lanczos_resampling):\n\nker(x) = S/(2*(π*x)^2)*sin(π*x)*sin(2*π*x/S)     if |x| ≤ S/2\n         0                                       if |x| ≥ S/2\n\nThe expression ker' yields the first derivative of a Lanczos re-sampling kernel ker (also see the constructor LanczosKernelPrime).\n\n\n\n\n\n","category":"type"},{"location":"library/#InterpolationKernels.LanczosKernelPrime","page":"Reference","title":"InterpolationKernels.LanczosKernelPrime","text":"LanczosKernelPrime([T=Float64,] S, B=Flat)\n\nyields a kernel instance that is the 1st derivative of the Lanczos re-sampling kernel (see LanczosKernel) of support size S and for floating-point type T and boundary conditions B.\n\n\n\n\n\n","category":"type"},{"location":"basics/#Basic-usage-1","page":"Basic usage","title":"Basic usage","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"An interpolation kernel Kernel{T,S,B} is parametrized by the floating-point type T of its coefficients, by the size S of its support and by the boundary conditions B applied for extrapolation (see Boundary conditions).  For efficiency reasons, only kernels with (small) finite size supports are implemented.  To create a kernel instance, call its constructor; for example:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"ker = LanczosKernel(6)","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"yields a Lanczos re-sampling kernel of size 6 (see Interpolation kernels for an exhaustive list of kernels implemented in InterpolationKernels).","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Any interpolation kernel ker is a callable object which may be used as a function with a real argument:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"    ker(x::Real)","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"yields kernel value at offset x.  All kernel supports are symmetric; that is ker(x) is zero if abs(x) > S/2 with S the size of the kernel support.","category":"page"},{"location":"basics/#Simple-methods-1","page":"Basic usage","title":"Simple methods","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Some simple methods are available for any interpolation kernel ker:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"eltype(ker) yields the floating-point type T for calculations;\nlength(ker) yields the number S of samples in the support of ker which is also the number of neighbors involved in an interpolation by this kernel;\nboundaries(ker) yields B the type of the boundary conditions applied for extrapolation.","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Since the floating-point type T, the support size S and the boundary conditions B are parameters of the interpolation kernel type, the above methods can also be applied to the type of an interpolation kernel.","category":"page"},{"location":"basics/#Traits-1","page":"Basic usage","title":"Traits","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Methods iscardinal and isnormalized can be used to query whether a kernel is a cardinal function (that is a function which yields zero for all non-zero integers) and whether a kernel has the partition of unity property.  For some parametric kernels, these traits depend on the specific values of the parameters so these methods take a kernel instance (not a type) as argument.","category":"page"},{"location":"basics/#Derivative-1","page":"Basic usage","title":"Derivative","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"The expression ker' yields a kernel instance which is the 1st derivative of the kernel ker.  Having the derivative of a kernel is useful because, thanks to linearity of the interpolation, interpolating an array with the derivative ker' is equivalent of taking the 1st derivative of the continuous function given by interpolating the same array with the kernel ker.","category":"page"},{"location":"basics/#Interpolation-weights-1","page":"Basic usage","title":"Interpolation weights","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Efficient computation of interpolation weights is implemented by the getweights method.  The principles of interpolation are detailed in another section.","category":"page"},{"location":"basics/#Kernel-conversion-1","page":"Basic usage","title":"Kernel conversion","text":"","category":"section"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"A kernel object ker can be converted to change its floating-point type and/or its boundary conditions.  For example, assuming ker is a kernel instance, one can do:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"convert(Kernel{Float32}, ker)\nconvert(Kernel{eltype(ker),length(ker),SafeFlat}, ker)","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"to use Float32 floating-point arithmetic or to choose SafeFlat boundary conditions but keeping the same floating-point type and (of course) the same support size.","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Such expressions are a bit tedious to type, so shortcuts are provided.  It is sufficient to call a kernel with the new floating-point type T and/or boundary conditions B to perform the conversion:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"ker([T::Type{<:AbstractFloat} = eltype(ker),] B::Type{<:Boundaries}=boundaries(ker))","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"where any of T or B can be omitted to keep the current kernel setting and their order is irrelevant.  Beware that changing the floating-point type may lead to a loss of precision if the new floating-point type has more digits.  It is possible to change the floating-point type of a kernel or its boundary conditions by something like:","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"Float32(ker)    # change floating-point type of kernel `ker`\nSafeFlat(ker)   # change boundary conditions of kernel `ker`","category":"page"},{"location":"basics/#","page":"Basic usage","title":"Basic usage","text":"The above calls do not follow the usuall conventions that a constructor may be called to convert its argument(s) to an instance of its type, this is however practical.","category":"page"},{"location":"install/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"The easiest way to install InterpolationKernels is via Julia registry EmmtRegistry:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"using Pkg\npkg\"registry add https://github.com/emmt/EmmtRegistry\"\npkg\"add InterpolationKernels\"","category":"page"},{"location":"interpolation/#Interpolation-1","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Interpolation kernels, as their name suggest, are designed for interpolating arrays.  The InterpolationKernels package provides the getweights method to efficiently compute interpolation weights for a given kernel and offset.","category":"page"},{"location":"interpolation/#Interpolation-principles-1","page":"Interpolation","title":"Interpolation principles","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"To explain how linear interpolation works, let us assume that we want to interpolate a source vector src using the kernel ker: ℝ → ℝ to produce a continuous model function mdl(x) with x ∈ ℝ the continuous coordinate. Such a model writes:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"mdl(x) = sum_{j ∈ J} ker(x - j)*src[j]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where sum_{j ∈ J} denotes a sum over all indices j of src, that is J = axes(src,1).  The above equation is a convolution of the source src by the kernel ker.  The model function is mdl: ℝ → 𝕂 where 𝕂 is the type of the product in the above sum.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"If the kernel ker has a finite support of size S ∈ ℕ, there are at most S nonzero ker(…) terms in the sum.  Moreover, if S is much smaller than the length of src and to spare computations, it is worth rewriting the result of the interpolation as:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"mdl(x) = sum_{k ∈ 1:S} ker(x + p - k)*src[k - p]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"for some well chosen p ∈ ℤ so that the sum over k accounts for all nonzero ker(…) terms.  This means that if [kmin,kmax] is the support of ker(x) (with kmax = kmin + S), then the following inequalities must hold:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"kmin ≤ x + p - maximum(1:S) ≤ x + p - minimum(1:S) ≤ kmax","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where minimum(1:S) ≡ 1 and maximum(1:S) ≡ S are the minimum and the maximum indices k in the sum sum_{k ∈ 1:S}.  Re-arranging terms yields that pmin ≤ p ≤ pmax must hold with:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"pmin = kmin - x + S\npmax = kmax - x + 1","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Note that the width of the interval [pmin,pmax] is pmax - pmin = 1 since kmax = kmin + S, so the interval [pmin,pmax] always contains at least one integer and contains at most two integers when pmin (and pmax) is integer. This leaves 2 possibilities for choosing p ∈ [pmin,pmax] ∩ ℤ:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"p = ceil(pmax) - 1 =  ceil(kmax - x)\np = floor(pmax)    = floor(kmax - x + 1)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"which are equivalent for most but not all values of x (they differ when kmax-x happens to be integer).  If ker(kmin) = ker(kmax) = 0, which should be the case if ker(x) is everywhere continuous, the choice between these two possibilities is irrelevant for the result of the interpolation.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Now introducing the so-called interpolation weights given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"w[k] = ker(x + p - k)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"for k ∈ 1:S, the interpolation can be rewritten as","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"dst[i] = sum_{k ∈ 1:S} w[k]*src[k - p]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"which is a correlation of w and src.","category":"page"},{"location":"interpolation/#Interpolation-weights-1","page":"Interpolation","title":"Interpolation weights","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"In InterpolationKernels all kernels have a symmetric support, hence kmin = -kmax and kmax = S/2.  The interpolation weights are then given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"w[k] = ker(x + ceil(S/2 - x) - k)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"for k ∈ 1:S and assuming that p = ceil(kmax - x) has been chosen among the two possibilities.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Instead of computing the nonzero interpolation weights one by one by S calls to the kernel function, it may be beneficial to compute all weights in a row exploiting common sub-expressions.  This facility is provided by the kernels in InterpolationKernels and the interpolation weights for kernel ker can be computed by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"w = getweights(ker, t)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"which yields an S-tuple w of weights with S the size of the support of the kernel ker.  To interpolate around position x (in fractional index units), the offset t is given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"if S is even:\nt = x - floor(x)\nif S is odd:\nt = x - floor(x + 1/2) = x - round(x)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"The offset t is therefore in the range [0,1] for S even and in the range [-1/2,+1/2] for S odd.  The bounds being inclusive or not is irrelevant for the result (so the rounding direction does not matter).","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"One of the reasons of using these conventions is that the integer index:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"j = (iseven(S) ? floor(Int, x) : round(Int, x))","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"such that t = x - j plays a central role in determining the indices of the entries in the interpolated array involved in the interpolation formula.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"For developers who would like to implement other kernels than those provided by InterpolationKernels, it is necessary to derive the general formula for the weights as functions of the offset t.  Recalling that w[k] = ker(v - k) with v = x + ceil(S/2 - x), the identity ceil(-u) = -floor(u) for any real u can be used to rewrite v as:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"v = x + ceil(S/2 - x)\n  = x - floor(x - S/2)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"now 2 different cases must be considered depending on the parity of S:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"if S is even, then S = 2c with c integer, therefore S/2 = c and:\nv = x - floor(x - c) = x - floor(x) + c = t + c\nif S is odd, then S = 2c - 1 with c integer, therefore S/2 = c - 1/2 and:\nv = x - floor(x - c + 1/2) = x - floor(x + 1/2) + c = t + c","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"To summarize, the interpolations weights are simply given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"w[k] = ker(t + c - k)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"c = (S + 1) ÷ 2","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with ÷ the integer division in Julia.","category":"page"},{"location":"interpolation/#Example:-fine-shifting-1","page":"Interpolation","title":"Example: fine shifting","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Let us now assume that we want to compute:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"dst[i] ≈ src[i - r]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"for all indices i ∈ I of the destination vector dst and some non-integer offset r where ≈ denotes the approximation by the interpolation model mdl(x) described above.  Hence dst is the result of performing a sub-sample shift of src by offset r.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Combining equations (that is just replace x by i-r) yields:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"dst[i] = mdl(i - r)\n       = sum_{j ∈ J} ker(i - r - j)*src[j]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"In order to spare computations, we take j = i - q + k for some well chosen integer q and rewrite the interpolation as:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"dst[i] = sum_{k ∈ 1:R} ker(q - r - k)*src[i - q + k]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"we have to chose q such that the following inequalities hold:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"kmin ≤ q - r - S ≤ q - r - 1 ≤ kmax","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with [kmin,kmax] the support of the kernel ker and kmax - kmin = S as before.  These inequalities are equivalent to:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"(qmin = kmin + r + S) ≤ q ≤ (qmax = kmax + r + 1)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"as before qmax - qmin = 1 and there are 2 possibilities for choosing q:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"q = ceil(qmax) - 1 = ceil(kmax + r)\nq = floor(qmax) = floor(kmax + 1 + r)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Taking the second choice for q and assuming a symmetric support (hence kmax = S/2) yields:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"q = floor(S/2 + 1 + r)\n  = floor(c + r)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where c = 1 + S/2.  The interpolation weights are now given by:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"w[k] = ker(v - k)","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"with:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"v = q - r\n  = floor(S/2 + 1 + r) - r","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Finally the result of fine shifting writes:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"dst[i] = sum_{k ∈ 1:R} w[k]*src[i - q + k]","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"where the weights w and offset q do not depend on i and can thus be pre-computed resulting in very fast computations.  This is exploited by the FineShift package.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"If flat boundary conditions hold, we are assuming that src[j] = src[1] if j ≤ 1 and src[j] = src[n] if j ≥ n with n = length(src) the number of samples in src.  Then, if the shift r is too large (in magnitude) all j = i + k - q for k = 1, ..., S are below or above the limits in the interpolation formula.  This occurs when:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"i + k - q ≤ 1  (∀ i,k)  <=> i + S - 1 ≤ q  (∀ i)  <=> S + m - 1 ≤ q\ni + k - q ≥ n  (∀ i,k)  <=>         i ≥ q  (∀ i)  <=> 1 ≥ q","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The InterpolationKernels package provides a library of interpolation kernels for Julia.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The source code is on GitHub.","category":"page"},{"location":"#Table-of-contents-1","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"install.md\", \"basics.md\", \"kernels.md\", \"boundaries.md\",\n         \"interpolation.md\", \"library.md\"]","category":"page"},{"location":"#Index-1","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"boundaries/#Boundary-conditions-1","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"boundaries/#","page":"Boundary conditions","title":"Boundary conditions","text":"In InterpolationKernels, the boundary conditions indicate how missing values should be extrapolated.","category":"page"},{"location":"boundaries/#","page":"Boundary conditions","title":"Boundary conditions","text":"The boundary conditions are specified for convenience and to provide a unified behavior.  The boundary conditions are not directly used by the implemented kernels but are part of the kernel types and should be taken into account by interpolation methods using the kernel instances.","category":"page"},{"location":"boundaries/#","page":"Boundary conditions","title":"Boundary conditions","text":"Calling the boundaries method on a kernel (or on a kernel type) yields the type of boundary conditions associated to the kernel.","category":"page"}]
}
